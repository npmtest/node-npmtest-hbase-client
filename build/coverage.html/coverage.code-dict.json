{"/home/travis/build/npmtest/node-npmtest-hbase-client/test.js":"/* istanbul instrument in package npmtest_hbase_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-hbase-client/lib.npmtest_hbase_client.js":"/* istanbul instrument in package npmtest_hbase_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_hbase_client = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_hbase_client = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-hbase-client/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-hbase-client && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_hbase_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_hbase_client\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_hbase_client.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_hbase_client.rollup.js'] =\n            local.assetsDict['/assets.npmtest_hbase_client.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_hbase_client.__dirname + '/lib.npmtest_hbase_client.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/index.js":"/*!\n * node-hbase-client - index.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nexports.TimeRange = require('./lib/time_range');\nexports.Get = require('./lib/get');\nexports.Put = require('./lib/put');\nexports.Scan = require('./lib/scan');\nexports.Result = require('./lib/result');\nexports.Client = require('./lib/client');\nexports.Delete = require('./lib/delete');\nexports.filters = require('./lib/filters');\n\nexports.create = exports.Client.create;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/time_range.js":"/*!\n * node-hbase-client - lib/time_range.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar Long = require('long');\nvar Bytes = require('./util/bytes');\n\n/**\n * Represents an interval of version timestamps.\n * <p>\n * Evaluated according to minStamp <= timestamp < maxStamp\n * or [minStamp,maxStamp) in interval notation.\n * <p>\n * Only used internally; should not be accessed directly by clients.\n */\nfunction TimeRange(minStamp, maxStamp, allTime) {\n  if (Buffer.isBuffer(minStamp)) {\n    minStamp = Bytes.toLong(minStamp);\n  }\n  if (Buffer.isBuffer(maxStamp)) {\n    maxStamp = Bytes.toLong(maxStamp);\n  }\n  \n  this.minStamp = minStamp || 0;\n  this.maxStamp = maxStamp || Long.MAX_VALUE;\n  if (allTime === undefined || allTime === null) {\n    allTime = true;\n  }\n  this.allTime = allTime;\n}\n\n/**\n * Compare the timestamp to timerange\n * @param timestamp\n * @return -1 if timestamp is less than timerange,\n * 0 if timestamp is within timerange,\n * 1 if timestamp is greater than timerange\n */\nTimeRange.prototype.compare = function (timestamp) {\n  if (timestamp < this.minStamp) {\n    return -1;\n  } else if (timestamp >= this.maxStamp) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n\nTimeRange.prototype.toString = function () {\n  return \"maxStamp=\" + this.maxStamp.toString() + \", minStamp=\" + this.minStamp.toString();\n};\n\n//Writable\nTimeRange.prototype.readFields = function (io) {\n  this.minStamp = io.readLong();\n  this.maxStamp = io.readLong();\n  this.allTime = io.readBoolean();\n};\n\nTimeRange.prototype.write = function (out) {\n  out.writeLong(this.minStamp);\n  out.writeLong(this.maxStamp);\n  out.writeBoolean(this.allTime);\n};\n\n\nmodule.exports = TimeRange;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/util/bytes.js":"/*!\n * node-hbase-client - lib/bytes.js\n *\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar utility = require('utility');\nvar Long = require('long');\nvar WritableUtils = require('../writable_utils');\nvar errors = require('../errors');\nvar IllegalArgumentException = errors.IllegalArgumentException;\nvar NegativeArraySizeException = errors.NegativeArraySizeException;\n\nvar SIZEOF_BYTE = exports.SIZEOF_BYTE = 1;\nvar SIZEOF_BOOLEAN = exports.SIZEOF_BOOLEAN = 1;\nvar SIZEOF_CHAR = exports.SIZEOF_CHAR = 2;\nvar SIZEOF_SHORT = exports.SIZEOF_SHORT = 2;\nvar SIZEOF_INT = exports.SIZEOF_INT = 4;\nvar SIZEOF_DOUBLE = exports.SIZEOF_DOUBLE = 8;\nvar SIZEOF_LONG = exports.SIZEOF_LONG = 8;\n\n/**\n * Write byte-array to out with a vint length prefix.\n * @param out output stream\n * @param b array\n * @param offset offset into array\n * @param length length past offset\n */\nexports.writeByteArray = function (out, b, offset, length) {\n  length = length || (b && b.length) || 0;\n  offset = offset || 0;\n  WritableUtils.writeVInt(out, length);\n  if (length > 0) {\n    out.write(b, offset, length);\n  }\n};\n\n/**\n * Put an int value out to the specified byte array position.\n * @param bytes the byte array\n * @param offset position in the array\n * @param val int to write out\n * @return incremented offset\n * @throws IllegalArgumentException if the byte array given doesn't have\n * enough room at the offset specified.\n */\nexports.putInt = function (bytes, offset, val) {\n  bytes.writeInt32BE(val, offset);\n  return offset + SIZEOF_INT;\n};\n\n/**\n * Put a short value out to the specified byte array position.\n * @param bytes the byte array\n * @param offset position in the array\n * @param val short to write out\n * @return incremented offset\n * @throws IllegalArgumentException if the byte array given doesn't have\n * enough room at the offset specified.\n */\nexports.putShort = function (bytes, offset, val) {\n  bytes.writeInt16BE(val, offset);\n  return offset + SIZEOF_SHORT;\n};\n\n/**\n * Put bytes at the specified byte array position.\n * @param bytes the byte array\n * @param offset position in the array\n * @param srcBytes array to write out\n * @return incremented offset\n */\nexports.putBytes = function (bytes, offset, srcBytes) {\n  srcBytes.copy(bytes, offset);\n  return offset + srcBytes.length;\n};\n\n/**\n * Write a single byte out to the specified byte array position.\n * @param bytes the byte array\n * @param offset position in the array\n * @param b byte to write out\n * @return incremented offset\n */\nexports.putByte = function (bytes, offset, b) {\n  bytes[offset] = b;\n  return offset + 1;\n};\n\n/**\n * Put a long value out to the specified byte array position.\n *\n * @param bytes the byte array\n * @param offset position in the array\n * @param val long to write out\n * @return incremented offset\n * @throws IllegalArgumentException if the byte array given doesn't have\n * enough room at the offset specified.\n */\nexports.putLong = function (bytes, offset, val) {\n  if (!(val instanceof Long)) {\n    val = Long.fromNumber(val);\n  }\n  bytes.writeInt32BE(val.high, offset);\n  bytes.writeInt32BE(val.low, offset + 4);\n  return offset + SIZEOF_LONG;\n};\n\n/**\n * Converts a byte array to an int value\n * @param bytes byte array\n * @param offset offset into array\n * @param length length of int (has to be {@link #SIZEOF_INT})\n * @return the int value\n * @throws IllegalArgumentException if length is not {@link #SIZEOF_INT} or\n * if there's not enough room in the array at the offset indicated.\n */\nexports.toInt = function (bytes, offset, length) {\n  return bytes.readInt32BE(offset);\n};\n\n/**\n * Converts a byte array to a short value\n * @param bytes byte array\n * @param offset offset into array\n * @param length length, has to be {@link #SIZEOF_SHORT}\n * @return the short value\n * @throws IllegalArgumentException if length is not {@link #SIZEOF_SHORT}\n * or if there's not enough room in the array at the offset indicated.\n */\nexports.toShort = function (bytes, offset, length) {\n  return bytes.readInt16BE(offset);\n};\n\n/**\n * Converts a string to a UTF-8 byte array.\n * @param s string\n * @return the byte array\n */\nexports.toBytes = function (s) {\n  if (s instanceof Long) {\n    return WritableUtils.toLongBytes(s);\n  }\n  if (Buffer.isBuffer(s)) {\n    return s;\n  }\n  return new Buffer(s, 'utf8');\n};\n\nexports.toString = function (b) {\n  return b.toString('utf8');\n};\n\n/**\n * @param left left operand\n * @param right right operand\n * @return True if equal\n */\nexports.equals = function (left, right) {\n  // Could use Arrays.equals?\n  //noinspection SimplifiableConditionalExpression\n  if (left === right) {\n    return true;\n  }\n  if (left === null || right === null) {\n    return false;\n  }\n  if (left.length !== right.length) {\n    return false;\n  }\n  if (left.length === 0) {\n    return true;\n  }\n\n  // Since we're often comparing adjacent sorted data,\n  // it's usual to have equal arrays except for the very last byte\n  // so check that first\n  if (left[left.length - 1] !== right[right.length - 1]) {\n    return false;\n  }\n\n  for (var i = 0; i < left.length; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Write a printable representation of a byte array. Non-printable\n * characters are hex escaped in the format \\\\x%02X, eg:\n * \\x00 \\x05 etc\n *\n * @param b array to write out\n * @param off offset to start at\n * @param len length to write\n * @return string output\n */\nexports.toStringBinary = function (b, off, len) {\n  return b.toString('utf8');\n  // off = off || 0;\n  // len = len || b.length;\n  // var result = '';\n  // var first = new String(b, off, len, \"ISO-8859-1\");\n  // for (int i = 0; i < first.length(); ++i) {\n  //   int ch = first.charAt(i) & 0xFF;\n  //   if ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')\n  //       || \" `~!@#$%^&*()-_=+[]{}\\\\|;:'\\\",.<>/?\".indexOf(ch) >= 0) {\n  //     result.append(first.charAt(i));\n  //   } else {\n  //     result.append(String.format(\"\\\\x%02X\", ch));\n  //   }\n  // }\n};\n\n/**\n * @return 0 if equal, < 0 if left is less than right, etc.\n */\nexports.compareTo = function (buffer1, buffer2) {\n  var length1 = buffer1.length;\n  var length2 = buffer2.length;\n  // Short circuit equal case\n  if (buffer1 === buffer2 && length1 === length2) {\n    return 0;\n  }\n  // Bring WritableComparator code local\n  for (var i = 0, j = 0; i < length1 && j < length2; i++, j++) {\n    var a = buffer1[i];\n    var b = buffer2[j];\n    if (a !== b) {\n      return a - b;\n    }\n  }\n  return length1 - length2;\n};\n\n/** Compute hash for binary data. */\nexports.hashBytes = function (bytes) {\n  var hash = 1;\n  for (var i = 0; i < bytes.length; i++) {\n    hash = (31 * hash) + bytes[i];\n  }\n  return hash;\n};\n\n/**\n * @param b bytes to hash\n * @return A hash of <code>b</code> as an Integer that can be used as key in\n * Maps.\n */\nexports.mapKey = function (bytes) {\n  return utility.md5(bytes);\n};\n\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/writable_utils.js":"/*jslint bitwise: true */\n/*!\n * node-hbase-client - lib/writable_utils.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar Long = require('long');\n\n/**\n * Serializes a long to a binary stream with zero-compressed encoding.\n * For -112 <= i <= 127, only one byte is used with the actual value.\n * \n * For other values of i, the first byte value indicates whether the\n * long is positive or negative, and the number of bytes that follow.\n * If the first byte value v is between -113 and -120, the following long\n * is positive, with number of bytes that follow are -(v+112).\n * If the first byte value v is between -121 and -128, the following long\n * is negative, with number of bytes that follow are -(v+120). Bytes are\n * stored in the high-non-zero-byte-first order.\n * \n * @param stream Binary output stream\n * @param i Long to be serialized\n */\nexports.writeVLong = function (stream, i) {\n  // TODO: support Long\n  if (i >= -112 && i <= 127) {\n    stream.writeByte(i);\n    return;\n  }\n\n  var len = -112;\n  if (i < 0) {\n    // i ^= -1L; // take one's complement'\n    i ^= -1; // take one's complement'\n    len = -120;\n  }\n\n  var tmp = i;\n  while (tmp !== 0) {\n    tmp = tmp >> 8;\n    len--;\n  }\n\n  // stream.writeByte(len);\n\n  var left = (len < -120) ? -(len + 120) : -(len + 112);\n  var buf = new Buffer(left + 1);\n  buf[0] = len;\n\n  for (var idx = left, bi = 1; idx !== 0; idx--, bi++) {\n    var shiftbits = (idx - 1) * 8;\n    // var mask = 0xFFL << shiftbits;\n    var mask = 0xFF << shiftbits;\n    buf[bi] = (i & mask) >> shiftbits;\n  }\n\n  stream.writeBytes(buf);\n};\n\n/**\n * Serializes an integer to a binary stream with zero-compressed encoding.\n * For -120 <= i <= 127, only one byte is used with the actual value.\n * For other values of i, the first byte value indicates whether the\n * integer is positive or negative, and the number of bytes that follow.\n * If the first byte value v is between -121 and -124, the following integer\n * is positive, with number of bytes that follow are -(v+120).\n * If the first byte value v is between -125 and -128, the following integer\n * is negative, with number of bytes that follow are -(v+124). Bytes are\n * stored in the high-non-zero-byte-first order.\n *\n * @param stream Binary output stream\n * @param i Integer to be serialized\n * @throws java.io.IOException \n */\nexports.writeVInt = function (stream, i) {\n  exports.writeVLong(stream, i);\n};\n\n/**\n * Reads a zero-compressed encoded long from input stream and returns it.\n * @param stream Binary input stream\n * @throws java.io.IOException \n * @return deserialized long from stream.\n */\nexports.readVLong = function (stream, callback) {\n  // TODO: support Long\n  stream.readFields([{name: 'firstByte', method: 'readByte'}], function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n    var firstByte = data.firstByte;\n    var len = exports.decodeVIntSize(firstByte);\n    if (len === 1) {\n      return callback(null, firstByte);\n    }\n    var size = len - 1;\n    stream.readFully(size, function (err, buf) {\n      if (err) {\n        return callback(err);\n      }\n      var i = 0;\n      for (var idx = 0; idx < size; idx++) {\n        var b = buf[idx];\n        i = i << 8;\n        i = i | (b & 0xFF);\n      }\n      callback(null, exports.isNegativeVInt(firstByte) ? (i ^ -1) : i);\n    });\n  });\n};\n\n/**\n * Reads a zero-compressed encoded integer from input stream and returns it.\n * @param stream Binary input stream\n * @throws java.io.IOException \n * @return deserialized integer from stream.\n */\nexports.readVInt = function (stream, callback) {\n  exports.readVLong(stream, callback);\n};\n\n/**\n * Given the first byte of a vint/vlong, determine the sign\n * @param value the first byte\n * @return is the value negative\n */\nexports.isNegativeVInt = function (value) {\n  return value < -120 || (value >= -112 && value < 0);\n};\n\n/**\n * Parse the first byte of a vint/vlong to determine the number of bytes\n * @param value the first byte of the vint/vlong\n * @return the total number of bytes (1 to 9)\n */\nexports.decodeVIntSize = function (value) {\n  if (value >= -112) {\n    return 1;\n  } else if (value < -120) {\n    return -119 - value;\n  }\n  return -111 - value;\n};\n\n/**\n * Convert v to Long.\n * \n * @param {Number|String} v\n * @return {Long}\n */\nexports.toLong = function (v) {\n  if (v instanceof Long) {\n    return v;\n  }\n  if (Buffer.isBuffer(v)) {\n    // buffer must be 8 bytes\n    return Long.fromBits(v.readInt32BE(4), v.readInt32BE(0));\n  }\n  if (typeof v === 'string') {\n    return Long.fromString(v);\n  }\n  return Long.fromNumber(v);\n};\n\nexports.toLongBytes = function (v) {\n  var buf = new Buffer(8);\n  var longV = exports.toLong(v);\n  buf.writeInt32BE(longV.high, 0);\n  buf.writeInt32BE(longV.low, 4);\n  return buf;\n};\n\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/errors.js":"/*!\n * node-hbase-client - lib/errors.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar util = require('util');\n\n// Create a new Abstract Error constructor\nvar AbstractError = function (msg, constr) {\n  // http://dustinsenos.com/articles/customErrorsInNode\n  //\n  // If defined, pass the constr property to V8's\n  // captureStackTrace to clean up the output\n  Error.captureStackTrace(this, constr || this);\n\n  // If defined, store a custom error message\n  this.message = msg || 'Error';\n};\n\n// Extend our AbstractError from Error\nutil.inherits(AbstractError, Error);\n\n// Give our Abstract error a name property. Helpful for logging the error later.\nAbstractError.prototype.name = 'AbstractError';\n\n\n// Runtime\nvar RuntimeException = function (msg) {\n  RuntimeException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(RuntimeException, AbstractError);\nRuntimeException.prototype.name = 'RuntimeException';\n\nvar UnsupportedOperationException = function (msg) {\n  UnsupportedOperationException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(UnsupportedOperationException, RuntimeException);\nUnsupportedOperationException.prototype.name = 'UnsupportedOperationException';\n\n\n// IO\nvar IOException = function (msg) {\n  IOException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(IOException, AbstractError);\nIOException.prototype.name = 'IOException';\n\n/**\n * Thrown when something happens related to region handling.\n * Subclasses have to be more specific.\n */\nvar RegionException = function (msg) {\n  RegionException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(RegionException, IOException);\nRegionException.prototype.name = 'RegionException';\n\n/** Thrown when a table can not be located */\nvar RegionOfflineException = function (msg) {\n  RegionOfflineException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(RegionOfflineException, RegionException);\nRegionOfflineException.prototype.name = 'RegionOfflineException';\n\n/**\n * Thrown when no region server can be found for a region\n */\nvar NoServerForRegionException = function (msg) {\n  NoServerForRegionException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(NoServerForRegionException, RegionException);\nNoServerForRegionException.prototype.name = 'NoServerForRegionException';\n\nvar TableNotFoundException = function (msg) {\n  TableNotFoundException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(TableNotFoundException, RegionException);\nTableNotFoundException.prototype.name = 'TableNotFoundException';\n\nvar NoServerForRegionException = function (msg) {\n  NoServerForRegionException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(NoServerForRegionException, RegionException);\nNoServerForRegionException.prototype.name = 'NoServerForRegionException';\n\nvar RemoteException = function (className, msg) {\n  RemoteException.super_.call(this, msg, this.constructor);\n  this.name = className;\n};\nutil.inherits(RemoteException, IOException);\nRemoteException.prototype.name = 'RemoteException';\n\nvar ConnectionClosedException = function (msg) {\n  ConnectionClosedException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(ConnectionClosedException, IOException);\nConnectionClosedException.prototype.name = 'ConnectionClosedException';\n\nvar ConnectionConnectTimeoutException = function (msg) {\n  ConnectionConnectTimeoutException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(ConnectionConnectTimeoutException, IOException);\nConnectionConnectTimeoutException.prototype.name = 'ConnectionConnectTimeoutException';\n\nvar RemoteCallTimeoutException = function (msg) {\n  RemoteCallTimeoutException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(RemoteCallTimeoutException, IOException);\nRemoteCallTimeoutException.prototype.name = 'RemoteCallTimeoutException';\n\nvar VersionMismatchException = function (expectedVersion, foundVersion) {\n  var msg = \"A record version mismatch occured. Expecting v\" + expectedVersion + \", found v\" + foundVersion;\n  VersionMismatchException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(VersionMismatchException, IOException);\nVersionMismatchException.prototype.name = 'VersionMismatchException';\n\n\n// Argument\nvar IllegalArgumentException = function (msg) {\n  IllegalArgumentException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(IllegalArgumentException, AbstractError);\nIllegalArgumentException.prototype.name = 'IllegalArgumentException';\n\nvar NegativeArraySizeException = function (msg) {\n  NegativeArraySizeException.super_.call(this, msg, this.constructor);\n};\nutil.inherits(NegativeArraySizeException, AbstractError);\nNegativeArraySizeException.prototype.name = 'NegativeArraySizeException';\n\n\n\nmodule.exports = {\n  AbstractError: AbstractError,\n\n  // IO\n  IOException: IOException,\n  RegionException: RegionException,\n  TableNotFoundException: TableNotFoundException,\n  RemoteException: RemoteException,\n  VersionMismatchException: VersionMismatchException,\n  RemoteCallTimeoutException: RemoteCallTimeoutException,\n  ConnectionClosedException: ConnectionClosedException,\n  ConnectionConnectTimeoutException: ConnectionConnectTimeoutException,\n\n  RegionOfflineException: RegionOfflineException,\n\n  // Runtime\n  RuntimeException: RuntimeException,\n  UnsupportedOperationException: UnsupportedOperationException,\n\n\n  IllegalArgumentException: IllegalArgumentException,\n  NegativeArraySizeException: NegativeArraySizeException,\n\n};\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/get.js":"/*!\n * node-hbase-client - lib/get.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar HbaseObjectWritable = require('./io/hbase_object_writable');\nvar eventproxy = require('eventproxy');\nvar IOException = require('./errors').IOException;\nvar util = require('util');\nvar Bytes = require('./util/bytes');\nvar TimeRange = require('./time_range');\nvar OperationWithAttributes = require('./operation_with_attributes');\n\nvar GET_VERSION = 2;\n\nfunction Get(row, rowLock) {\n  if (!(this instanceof Get)) {\n    return new Get(row, rowLock);\n  }\n\n  OperationWithAttributes.call(this);\n\n  if (row && !Buffer.isBuffer(row)) {\n    row = Bytes.toBytes(row);\n  }\n\n  this.row = row;\n  this.lockId = -1;\n  if (rowLock) {\n    this.lockId = rowLock.getLockId();\n  }\n  this.maxVersions = 1;\n  this.cacheBlocks = true;\n  this.filter = null;\n  this.tr = new TimeRange();\n  this.familyMap = {};\n}\n\nutil.inherits(Get, OperationWithAttributes);\n\n/**\n * Get all columns from the specified family.\n * <p>\n * Overrides previous calls to addColumn for this family.\n *\n * @param family family name\n * @return the Get object\n */\nGet.prototype.addFamily = function (family) {\n  delete this.familyMap[family];\n  this.familyMap[family] = null;\n  return this;\n};\n\n/**\n * Get the column from the specific family with the specified qualifier.\n * <p>\n * Overrides previous calls to addFamily for this family.\n *\n * @param family family name\n * @param qualifier column qualifier\n * @return the Get objec\n */\nGet.prototype.addColumn = function (family, qualifier) {\n  var set = this.familyMap[family] || [];\n  set.push(qualifier);\n  this.familyMap[family] = set;\n  // NavigableSet<byte[]> set = familyMap.get(family);\n  // if (set == null) {\n  //   set = new TreeSet<byte[]>(Bytes.BYTES_COMPARATOR);\n  // }\n  // set.add(qualifier);\n  // familyMap.put(family, set);\n  return this;\n};\n\n/**\n * Get up to the specified number of versions of each column.\n *\n * @param maxVersions maximum versions for each column\n * @return this for invocation chaining\n */\nGet.prototype.setMaxVersions = function (maxVersions) {\n  if (maxVersions <= 0) {\n    maxVersions = 1;\n  }\n  this.maxVersions = maxVersions;\n  return this;\n};\n\n/**\n * Get versions of columns only within the specified timestamp range,\n * [minStamp, maxStamp).\n *\n * @param minStamp minimum timestamp value, inclusive\n * @param maxStamp maximum timestamp value, exclusive\n * @return this for invocation chaining\n */\nGet.prototype.setTimeRange = function (minStamp, maxStamp) {\n  this.tr = new TimeRange(minStamp, maxStamp);\n  return this;\n};\n\nGet.prototype.readFields = function (io) {\n  var version = io.readByte();\n  if (version > GET_VERSION) {\n    throw new IOException(\"unsupported version: \" + version);\n  }\n  this.version = version;\n  this.row = io.readByteArray();\n  this.lockId = io.readLong();\n  this.maxVersions = io.readInt();\n  var hasFilter = io.readBoolean();\n  if (hasFilter) {\n    this.filter.readFields(io);\n  }\n  this.hasFilter = hasFilter;\n  this.cacheBlocks = io.readBoolean();\n  this.tr = new TimeRange();\n  this.tr.readFields(io);\n  var familyMap = {};\n  var num = io.readInt();\n  for (var i = 0; i < num; i++) {\n    var family = Bytes.toString(io.readByteArray());\n    familyMap[family] = null;\n    var hasColumns = io.readBoolean();\n    if (hasColumns) {\n      var set = [];\n      var columnNum = io.readInt();\n      for (var j = 0; j < columnNum; j++) {\n        var qualifier = io.readByteArray();\n        set.push(qualifier);\n      }\n      familyMap[family] = set;\n    }\n  }\n  this.familyMap = familyMap;\n  this.readAttributes(io);\n};\n\nGet.prototype.write = function (out) {\n  out.writeByte(GET_VERSION);\n  Bytes.writeByteArray(out, this.row);\n  out.writeLong(this.lockId);\n  out.writeInt(this.maxVersions);\n  if (this.filter === null) {\n    out.writeBoolean(false);\n  } else {\n    out.writeBoolean(true);\n    Bytes.writeByteArray(out, Bytes.toBytes(this.filter.getClass().getName()));\n    this.filter.write(out);\n  }\n  out.writeBoolean(this.cacheBlocks);\n  this.tr.write(out);\n  // out.writeInt(familyMap.size());\n  out.writeInt(Object.keys(this.familyMap).length);\n  for (var family in this.familyMap) {\n    Bytes.writeByteArray(out, Bytes.toBytes(family));\n    var columnSet = this.familyMap[family];\n    if (columnSet === null) {\n      out.writeBoolean(false);\n    } else {\n      out.writeBoolean(true);\n      out.writeInt(columnSet.length);\n      for (var i = 0; i < columnSet.length; i++) {\n        var qualifier = columnSet[i];\n        Bytes.writeByteArray(out, Bytes.toBytes(qualifier));\n      }\n    }\n  }\n  this.writeAttributes(out);\n};\n\nGet.prototype.getRow = function () {\n  return this.row;\n};\n\n\nHbaseObjectWritable.addToClass('Get.class', Get);\nmodule.exports = Get;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/io/hbase_object_writable.js":"/*!\n * node-hbase-client - lib/io/hbase_object_writable.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('hbase:writable');\nvar Long = require('long');\nvar Bytes = require('../util/bytes');\nvar WritableUtils = require('../writable_utils');\nvar Text = require('../text');\nvar IOException = require('../errors').IOException;\nvar UnsupportedOperationException = require('../errors').UnsupportedOperationException;\n\nvar CODE_TO_CLASS = {};\nvar CLASS_TO_CODE = {};\n\nvar CLASSES = {};\n\nvar addToMap = function (clazzName, code) {\n  CLASS_TO_CODE[clazzName] = code;\n  CODE_TO_CLASS[code] = clazzName;\n};\n\nexports.addToClass = function (name, clazz) {\n  CLASSES[name] = clazz;\n  clazz.__classname = name;\n};\n\n////////////////////////////////////////////////////////////////////////////\n// WARNING: Please do not insert, remove or swap any line in this static  //\n// block.  Doing so would change or shift all the codes used to serialize //\n// objects, which makes backwards compatibility very hard for clients.    //\n// New codes should always be added at the end. Code removal is           //\n// discouraged because code is a short now.                               //\n////////////////////////////////////////////////////////////////////////////\n\nvar NOT_ENCODED = 0;\nvar code = NOT_ENCODED + 1;\n// Primitive types.\naddToMap('Boolean.TYPE', code++);\naddToMap('Byte.TYPE', code++);\naddToMap('Character.TYPE', code++);\naddToMap('Short.TYPE', code++);\naddToMap('Integer.TYPE', code++);\naddToMap('Long.TYPE', code++);\naddToMap('Float.TYPE', code++);\naddToMap('Double.TYPE', code++);\naddToMap('Void.TYPE', code++);\n\n// Other java types\naddToMap('String.class', code++);\naddToMap('byte[].class', code++);\naddToMap('byte[][].class', code++);\n\n// Hadoop types\naddToMap('Text.class', code++);\naddToMap('Writable.class', code++); // 14\naddToMap('Writable[].class', code++);\naddToMap('HbaseMapWritable.class', code++);\naddToMap('NullInstance.class', code++);\n\n// Hbase types\naddToMap('HColumnDescriptor.class', code++);\naddToMap('HConstants.Modify.class', code++);\n\naddToMap('Integer.class', code++);\naddToMap('Integer[].class', code++);\n\naddToMap('MyClass.class', code++);\naddToMap('MyClass.class', code++);\naddToMap('HRegionInfo.class', code++);\naddToMap('HRegionInfo[].class', code++);\naddToMap('HServerAddress.class', code++);\naddToMap('MyClass.class', code++);\naddToMap('HTableDescriptor.class', code++);\naddToMap('MyClass.class', code++);\n\n//\n// HBASE-880\n//\naddToMap('MyClass.class', code++);\naddToMap('Delete.class', code++);\naddToMap('Get.class', code++);\naddToMap('KeyValue.class', code++);\naddToMap('KeyValue[].class', code++);\naddToMap('Put.class', code++);\naddToMap('Put[].class', code++);\naddToMap('Result.class', code++);\naddToMap('Result[].class', code++);\naddToMap('Scan.class', code++);\n\naddToMap('WhileMatchFilter.class', code++);\naddToMap('PrefixFilter.class', code++);\naddToMap('PageFilter.class', code++);\naddToMap('InclusiveStopFilter.class', code++);\naddToMap('ColumnCountGetFilter.class', code++);\naddToMap('SingleColumnValueFilter.class', code++);\naddToMap('SingleColumnValueExcludeFilter.class', code++);\naddToMap('BinaryComparator.class', code++);\naddToMap('BitComparator.class', code++);\naddToMap('CompareFilter.class', code++);\naddToMap('RowFilter.class', code++);\naddToMap('ValueFilter.class', code++);\naddToMap('QualifierFilter.class', code++);\naddToMap('SkipFilter.class', code++);\naddToMap('WritableByteArrayComparable.class', code++);\naddToMap('FirstKeyOnlyFilter.class', code++);\naddToMap('DependentColumnFilter.class', code++);\n\naddToMap('Delete[].class', code++);\n\naddToMap('MyClass.class', code++);\naddToMap('MyClass.class', code++);\naddToMap('MyClass.class', code++);\n\naddToMap('List.class', code++);\n\naddToMap('NavigableSet.class', code++);\naddToMap('ColumnPrefixFilter.class', code++);\n\n// Multi\naddToMap('Row.class', code++);\naddToMap('Action.class', code++);\naddToMap('MultiAction.class', code++);\naddToMap('MultiResponse.class', code++);\n\n// coprocessor execution\naddToMap('Exec.class', code++);\naddToMap('Increment.class', code++);\n\naddToMap('KeyOnlyFilter.class', code++);\n\n// serializable\naddToMap('Serializable.class', code++);\n\naddToMap('RandomRowFilter.class', code++);\n\naddToMap('CompareOp.class', code++);\n\naddToMap('ColumnRangeFilter.class', code++);\n\naddToMap('HServerLoad.class', code++);\n\naddToMap('MyClass.class', code++);\n\naddToMap('HTableDescriptor[].class', code++);\n\naddToMap('Append.class', code++);\n\naddToMap('RowMutations.class', code++);\n\naddToMap('MyClass.class', code++);\n\n//java.lang.reflect.Array is a placeholder for arrays not defined above\nexports.GENERIC_ARRAY_CODE = code++;\naddToMap('Array.class', exports.GENERIC_ARRAY_CODE);\n\n// make sure that this is the last statement in this static block\nexports.NEXT_CLASS_CODE = code;\n\n/**\n * Read a {@link Writable}, {@link String}, primitive type, or an array of\n * the preceding.\n *\n * @param io, input stream.\n * @param objectWritable\n */\nexports.readObject = function (io, objectWritable, conf) {\n  var code = io.readVInt();\n  var declaredClass = CODE_TO_CLASS[code];\n  debug('readObject: code: %s, class: %s', code, declaredClass);\n  var instance;\n  // primitive types\n  if (declaredClass === 'Boolean.TYPE') { // boolean\n    instance = io.readBoolean();\n  } else if (declaredClass === 'Character.TYPE') { // char\n    instance = io.readChar();\n  } else if (declaredClass === 'Byte.TYPE') { // byte\n    instance = io.readByte();\n  } else if (declaredClass === 'Short.TYPE') { // short\n    instance = io.readShort();\n  } else if (declaredClass === 'Integer.TYPE') { // int\n    instance = io.readInt();\n  } else if (declaredClass === 'Long.TYPE') { // long\n    instance = io.readLong();\n  } else if (declaredClass === 'Float.TYPE') { // float\n    instance = io.readFloat();\n  } else if (declaredClass === 'Double.TYPE') { // double\n    instance = io.readDouble();\n  } else if (declaredClass === 'Void.TYPE') { // void\n    instance = null;\n    // array\n  } else if (declaredClass === 'byte[].class') {\n    instance = Bytes.readByteArray(io);\n  } else if (declaredClass === 'Result[].class') {\n    var Result = CLASSES['Result.class'];\n    instance = Result.readArray(io);\n  // } else {\n  //   var length = io.readInt();\n  //   instance = Array.newInstance(declaredClass.getComponentType(), length);\n  //   for (var i = 0; i < length; i++) {\n  //     Array.set(instance, i, readObject(io, null, conf));\n  //   }\n  // } else if (declaredClass === 'Array.class') { //an array not declared in CLASS_TO_CODE\n  //   // Class<?> componentType = readClass(conf, in);\n  //   var length = io.readInt();\n    // console.log(declaredClass, length)\n    // instance = Array.newInstance(componentType, length);\n    // for (int i = 0; i < length; i++) {\n    //   Array.set(instance, i, readObject(in, conf));\n    // }\n  // } else if (List.class.isAssignableFrom(declaredClass)) { // List\n  //   int length = in.readInt();\n  //   instance = new ArrayList(length);\n  //   for (int i = 0; i < length; i++) {\n  //     ((ArrayList) instance).add(readObject(in, conf));\n  //   }\n  } else if (declaredClass === 'String.class') { // String\n    // instance = Text.readString(io);\n    instance = io.readVString();\n  // } else if (declaredClass.isEnum()) { // enum\n  //   instance = Enum.valueOf((Class<? extends Enum>) declaredClass, Text.readString(in));\n\n  //   //    } else if (declaredClass == Message.class) {\n  //   //      String className = Text.readString(in);\n  //   //      try {\n  //   //        declaredClass = getClassByName(conf, className);\n  //   //        instance = tryInstantiateProtobuf(declaredClass, in);\n  //   //      } catch (ClassNotFoundException e) {\n  //   //        LOG.error(\"Can't find class \" + className, e);\n  //   //        throw new IOException(\"Can't find class \" + className, e);\n  //   //      }\n  } else {\n    // Writable or Serializable\n    // int b = (byte) WritableUtils.readVInt(in);\n    var b = io.readVInt();\n    var name = CODE_TO_CLASS[b];\n\n    debug('writable class: code: %s, name: %s', b, name);\n\n    if (b === NOT_ENCODED) {\n      // String className = Text.readString(in);\n      name = io.readVString();\n      // try {\n      //   instanceClass = getClassByName(conf, className);\n      // } catch (ClassNotFoundException e) {\n      //   LOG.error(\"Can't find class \" + className, e);\n      //   throw new IOException(\"Can't find class \" + className, e);\n      // }\n    } else if (name === 'NullInstance.class') {\n      instance = null;\n    } else {\n      var instanceClass = CLASSES[name];\n      instance = instanceClass();\n\n      if (typeof instance.readFields === 'function') {\n        instance.readFields(io);\n      } else {\n        var len = io.readInt();\n        var objectBytes = io.read(len);\n        instance = objectBytes;\n      }\n    }\n\n    declaredClass = name;\n  }\n\n  if (objectWritable) { // store values\n    objectWritable.declaredClass = declaredClass;\n    objectWritable.instance = instance;\n  }\n  return instance;\n};\n\nexports.readFields = function (io) {\n  var obj = {};\n  exports.readObject(io, obj);\n  return obj;\n};\n\n/**\n * Write a {@link Writable}, {@link String}, primitive type, or an array of\n * the preceding.\n *\n * @param out, output stream.\n * @param instance\n * @param declaredClass\n */\nexports.writeObject = function (out, instance, declaredClass) {\n  var name;\n  var clazz;\n  if (!instance && declaredClass === 'Writable.class') {\n    instance = new NullInstance(declaredClass);\n    clazz = 'NullInstance.class';\n  } else {\n    name = instance.constructor.name;\n    clazz = name + '.class';\n  }\n\n  if (Buffer.isBuffer(instance)) {\n    clazz = 'byte[].class';\n    exports.writeClassCode(out, clazz);\n    Bytes.writeByteArray(out, instance);\n    return;\n  }\n  if (instance instanceof Long) {\n    clazz = 'Long.TYPE';\n    exports.writeClassCode(out, clazz);\n    out.writeLong(instance);\n    return;\n  }\n\n  if (clazz === 'Number.class') {\n    // TODO: double, float\n    clazz = 'Integer.TYPE';\n  }\n\n  if (declaredClass === 'Writable.class') {\n    exports.writeClassCode(out, declaredClass);\n  } else {\n    exports.writeClassCode(out, clazz);\n  }\n\n  // writable\n  if (typeof instance.write === 'function') {\n    if (clazz in CLASS_TO_CODE) {\n      exports.writeClassCode(out, clazz);\n    } else {\n      out.writeByte(NOT_ENCODED);\n      Text.writeString(out, instance.constructor.classname);\n    }\n    instance.write(out);\n    return;\n  }\n\n  if (clazz === 'String.class') {\n    Text.writeString(out, instance);\n    return;\n  }\n  // int\n  if (clazz === 'Integer.TYPE') {\n    out.writeInt(instance);\n    return;\n  }\n\n  throw new IOException(\"Can't write: \" + instance + \" as \" + clazz);\n};\n\n/**\n * Write out the code for passed Class.\n *\n * @param out\n * @param c\n */\nexports.writeClassCode = function (out, c) {\n  var code = CLASS_TO_CODE[c];\n  debug('writeClassCode: code: %s, class: %s', code, c);\n  if (code === null || code === undefined) {\n    throw new UnsupportedOperationException(\"No code for unexpected \" + c);\n  }\n  WritableUtils.writeVInt(out, code);\n};\n\n\nfunction NullInstance(declaredClass) {\n  this.declaredClass = declaredClass;\n}\n\nNullInstance.prototype.write = function (out) {\n  exports.writeClassCode(out, this.declaredClass);\n};\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/text.js":"/*!\n * node-hbase-client - lib/text.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar WritableUtils = require('./writable_utils');\n\n/** Write a UTF8 encoded string to out\n */\nexports.writeString = function (out, s) {\n  var bytes = new Buffer(s, 'utf8');\n  var length = bytes.length;\n  WritableUtils.writeVInt(out, length);\n  out.write(bytes);\n  return length;\n};\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/operation_with_attributes.js":"/*!\n * node-hbase-client - lib/operation_with_attributes.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar eventproxy = require('eventproxy');\nvar Bytes = require('./util/bytes');\nvar WritableUtils = require('./writable_utils');\n\nfunction OperationWithAttributes() {\n  this.attributes = {};\n}\n\n/**\n * Set attribute.\n * \n * @param {String} name\n * @param {Bytes} value\n */\nOperationWithAttributes.prototype.setAttribute = function (name, value) {\n  if (!this.attributes && (value === null || value === undefined)) {\n    return;\n  }\n\n  if (!this.attributes) {\n    this.attributes = {};\n  }\n\n  if (value === null || value === undefined) {\n    delete this.attributes[name];\n    if (Object.keys(this.attributes).length === 0) {\n      this.attributes = null;\n    }\n  } else {\n    this.attributes[name] = value;\n  }\n};\n\nOperationWithAttributes.prototype.getAttribute = function (name) {\n  if (!this.attributes) {\n    return null;\n  }\n  return this.attributes[name];\n};\n\nOperationWithAttributes.prototype.getAttributesMap = function () {\n  return this.attributes || {};\n};\n\nOperationWithAttributes.prototype.writeAttributes = function (out) {\n  if (!this.attributes) {\n    out.writeInt(0);\n  } else {\n    out.writeInt(Object.keys(this.attributes).length);\n    for (var name in this.attributes) {\n      WritableUtils.writeString(out, name);\n      Bytes.writeByteArray(out, this.attributes[name]);\n    }\n  }\n};\n\nOperationWithAttributes.prototype.readAttributes = function (io) {\n  var numAttributes = io.readInt();\n  if (numAttributes > 0) {\n    this.attributes = {};\n    for (var i = 0; i < numAttributes; i++) {\n      var name = io.readString();\n      var value = io.readByteArray();\n      this.attributes.put(name, value);\n    }\n  }\n};\n\n\nmodule.exports = OperationWithAttributes;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/put.js":"/*!\n * node-hbase-client - lib/put.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar util = require('util');\nvar errors = require('./errors');\nvar KeyValue = require('./keyvalue');\nvar Bytes = require('./util/bytes');\nvar OperationWithAttributes = require('./operation_with_attributes');\nvar HConstants = require('./hconstants');\n\n/**\n * Used to perform Put operations for a single row.\n * <p>\n * To perform a Put, instantiate a Put object with the row to insert to and\n * for each column to be inserted, execute {@link #add(byte[], byte[], byte[]) add} or\n * {@link #add(byte[], byte[], long, byte[]) add} if setting the timestamp.\n */\n\nvar PUT_VERSION = 2;\n\n/**\n * Create a Put operation for the specified row, using a given timestamp, and an existing row lock.\n *\n * @param row row key\n * @param ts timestamp\n * @param rowLock previously acquired row lock, or null\n */\nfunction Put(row, ts, rowLock) {\n  OperationWithAttributes.call(this);\n\n  if (row && !Buffer.isBuffer(row)) {\n    row = Bytes.toBytes(row);\n  }\n  if (row === null || row.length > HConstants.MAX_ROW_LENGTH) {\n    throw new errors.IllegalArgumentException(\"Row key is invalid\");\n  }\n\n  this.row = row;\n  this.ts = ts || HConstants.LATEST_TIMESTAMP;\n  this.lockId = -1;\n  if (rowLock) {\n    this.lockId = rowLock.getLockId();\n  }\n  this.familyMap = {};\n  this.writeToWAL = true;\n}\n\nutil.inherits(Put, OperationWithAttributes);\n\nPut.prototype.getRow = function () {\n  return this.row;\n};\n\n/**\n * Add the specified column and value, with the specified timestamp as\n * its version to this Put operation.\n *\n * @param family family name\n * @param qualifier column qualifier\n * @param value column value\n * @param [ts] version timestamp\n * @return this\n */\nPut.prototype.add = function (family, qualifier, value, ts) {\n  var list = this.getKeyValueList(family);\n  var kv = this.createPutKeyValue(family, qualifier, ts || this.ts, value);\n  list.push(kv);\n  return this;\n};\n\n/*\n * Create a KeyValue with this objects row key and the Put identifier.\n *\n * @return a KeyValue with this objects row key and the Put identifier.\n */\nPut.prototype.createPutKeyValue = function (family, qualifier, ts, value) {\n  if (family && !Buffer.isBuffer(family)) {\n    family = Bytes.toBytes(family);\n  }\n  if (qualifier && !Buffer.isBuffer(qualifier)) {\n    qualifier = Bytes.toBytes(qualifier);\n  }\n  if (value && !Buffer.isBuffer(value)) {\n    value = Bytes.toBytes(value);\n  }\n  return KeyValue.createKeyValue(this.row, family, qualifier, ts, KeyValue.Type.Put, value);\n};\n\n/**\n * Creates an empty list if one doesnt exist for the given column family\n * or else it returns the associated list of KeyValue objects.\n *\n * @param family column family\n * @return a list of KeyValue objects, returns an empty list if one doesnt exist.\n */\nPut.prototype.getKeyValueList = function (family) {\n  var list = this.familyMap[family];\n  if (!list) {\n    list = this.familyMap[family] = [];\n  }\n  return list;\n};\n\nPut.prototype.write = function (out) {\n  out.writeByte(PUT_VERSION);\n  Bytes.writeByteArray(out, this.row);\n  out.writeLong(this.ts);\n  out.writeLong(this.lockId);\n  out.writeBoolean(this.writeToWAL);\n  out.writeInt(Object.keys(this.familyMap).length);\n  for (var family in this.familyMap) {\n    Bytes.writeByteArray(out, Bytes.toBytes(family));\n    var keys = this.familyMap[family];\n    out.writeInt(keys.length);\n    var totalLen = 0;\n    var j, kv;\n    for (j = 0; j < keys.length; j++) {\n      kv = keys[j];\n      totalLen += kv.getLength();\n    }\n    out.writeInt(totalLen);\n    for (j = 0; j < keys.length; j++) {\n      kv = keys[j];\n      out.writeInt(kv.getLength());\n      out.write(kv.getBuffer(), kv.getOffset(), kv.getLength());\n    }\n  }\n  this.writeAttributes(out);\n};\n\n\nmodule.exports = Put;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/keyvalue.js":"/*!\n * node-hbase-client - lib/keyvalue.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar Bytes = require('./util/bytes');\nvar WritableUtils = require('./writable_utils');\nvar HConstants = require('./hconstants');\n\n/**\n * Key type.\n * Has space for other key types to be added later.  Cannot rely on\n * enum ordinals . They change if item is removed or moved.  Do our own codes.\n */\nvar Type = {\n  Minimum: 0,\n  Put: 4,\n  Delete: 8, \n  DeleteColumn: 12, \n  DeleteFamily: 14,\n  // Maximum is used when searching; you look from maximum on down.\n  Maximum: 255,\n};\n\n/**\n * An HBase Key/Value.  This is the fundamental HBase Type.\n *\n * <p>If being used client-side, the primary methods to access individual fields\n * are {@link #getRow()}, {@link #getFamily()}, {@link #getQualifier()},\n * {@link #getTimestamp()}, and {@link #getValue()}.  These methods allocate new\n * byte arrays and return copies. Avoid their use server-side.\n *\n * <p>Instances of this class are immutable.  They do not implement Comparable\n * but Comparators are provided.  Comparators change with context,\n * whether user table or a catalog table comparison.  Its critical you use the\n * appropriate comparator.  There are Comparators for KeyValue instances and\n * then for just the Key portion of a KeyValue used mostly by {@link HFile}.\n *\n * <p>KeyValue wraps a byte array and takes offsets and lengths into passed\n * array at where to start interpreting the content as KeyValue.  The KeyValue\n * format inside a byte array is:\n * <keylength> <valuelength> <key> <value>\n * Key is further decomposed as:\n * <rowlength> <row> <columnfamilylength> <columnfamily> <columnqualifier> <timestamp> <keytype>\n * The `rowlength` maximum is `Short.MAX_SIZE`,\n * column family length maximum is\n * `Byte.MAX_SIZE`, and column qualifier + key length must\n * be < `Integer.MAX_SIZE`.\n * The column does not contain the family/qualifier delimiter, {@link #COLUMN_FAMILY_DELIMITER}\n *\n * KeyValue format:\n * | 4 bytes   | 4 bytes     |     |       |\n * | keylength | valuelength | key | value |\n *\n * Key format:\n * | 2 bytes   |     | 1 byte             |              |                        |  8 bytes  | 1 byte  |\n * | rowlength | row | columnfamilylength | columnfamily | columnfamily qualifier | timestamp | keytype |\n */\nfunction KeyValue(bytes, offset, length) {\n  this.bytes = bytes;\n  this.offset = offset || 0;\n  this.length = length || bytes.length;\n  this.keyLength = 0;\n  // default value is 0, aka DNC\n  this.memstoreTS = 0;\n  this.rowCache = null;\n  this.timestampCache = -1;\n}\n\n/**\n * Colon character in UTF-8\n */\nKeyValue.COLUMN_FAMILY_DELIMITER = ':';\nKeyValue.COLUMN_FAMILY_DELIM_ARRAY = new Buffer(KeyValue.COLUMN_FAMILY_DELIMITER);\n\n/** Size of the key length field in bytes*/\nKeyValue.KEY_LENGTH_SIZE = Bytes.SIZEOF_INT;\n\n/** Size of the key type field in bytes */\nKeyValue.TYPE_SIZE = Bytes.SIZEOF_BYTE;\n\n/** Size of the row length field in bytes */\nKeyValue.ROW_LENGTH_SIZE = Bytes.SIZEOF_SHORT;\n\n/** Size of the family length field in bytes */\nKeyValue.FAMILY_LENGTH_SIZE = Bytes.SIZEOF_BYTE;\n\n/** Size of the timestamp field in bytes */\nKeyValue.TIMESTAMP_SIZE = Bytes.SIZEOF_LONG;\n\n// Size of the timestamp and type byte on end of a key -- a long + a byte.\nKeyValue.TIMESTAMP_TYPE_SIZE = KeyValue.TIMESTAMP_SIZE + KeyValue.TYPE_SIZE;\n\n// Size of the length shorts and bytes in key.\nKeyValue.KEY_INFRASTRUCTURE_SIZE = KeyValue.ROW_LENGTH_SIZE + \n  KeyValue.FAMILY_LENGTH_SIZE + KeyValue.TIMESTAMP_TYPE_SIZE;\n\n// How far into the key the row starts at. First thing to read is the short\n// that says how long the row is.\nKeyValue.ROW_OFFSET = Bytes.SIZEOF_INT /*keylength*/+ Bytes.SIZEOF_INT /*valuelength*/;\n\n// Size of the length ints in a KeyValue datastructure.\nKeyValue.KEYVALUE_INFRASTRUCTURE_SIZE = KeyValue.ROW_OFFSET;\n\nKeyValue.humanReadableTimestamp = function (timestamp) {\n  if (timestamp === HConstants.LATEST_TIMESTAMP) {\n    return \"LATEST_TIMESTAMP\";\n  }\n  if (timestamp === HConstants.OLDEST_TIMESTAMP) {\n    return \"OLDEST_TIMESTAMP\";\n  }\n  return String.valueOf(timestamp);\n};\n\n//---------------------------------------------------------------------------\n//\n//  String representation\n//\n//---------------------------------------------------------------------------\n\nKeyValue.prototype.toString = function () {\n  if (!this.bytes || this.bytes.length === 0) {\n    return \"empty\";\n  }\n  var family = this.getFamily();\n  if (family) {\n    family = family.toString();\n  }\n  var qualifier = this.getQualifier();\n  if (qualifier) {\n    qualifier = qualifier.toString();\n  }\n  var timestamp = this.getTimestamp().toString();\n  return this.getRow().toString() + '/' + family + '/' + qualifier + '/' + timestamp + \n    \"/vlen=\" + this.getValueLength() + \"/ts=\" + this.memstoreTS;\n};\n\n//---------------------------------------------------------------------------\n//\n//  Public Member Accessors\n//\n//---------------------------------------------------------------------------\n\n/**\n * @return The byte array backing this KeyValue.\n */\nKeyValue.prototype.getBuffer = function () {\n  return this.bytes;\n};\n\n/**\n * @return Offset into {@link #getBuffer()} at which this KeyValue starts.\n */\nKeyValue.prototype.getOffset = function () {\n  return this.offset;\n};\n\n/**\n * @return Length of bytes this KeyValue occupies in {@link #getBuffer()}.\n */\nKeyValue.prototype.getLength = function () {\n  return this.length;\n};\n\n//---------------------------------------------------------------------------\n//\n//  Length and Offset Calculators\n//\n//---------------------------------------------------------------------------\n\n/**\n * @return Key offset in backing buffer..\n */\nKeyValue.prototype.getKeyOffset = function () {\n  return this.offset + KeyValue.ROW_OFFSET;\n};\n\nKeyValue.prototype.getKeyString = function () {\n  return Bytes.toStringBinary(this.getBuffer(), this.getKeyOffset(), this.getKeyLength());\n};\n\n/**\n * @return Length of key portion.\n */\nKeyValue.prototype.getKeyLength = function () {\n  if (this.keyLength === 0) {\n    this.keyLength = Bytes.toInt(this.bytes, this.offset);\n  }\n  return this.keyLength;\n};\n\n/**\n * @return Value offset\n */\nKeyValue.prototype.getValueOffset = function () {\n  return this.getKeyOffset() + this.getKeyLength();\n};\n\n/**\n * @return Value length\n */\nKeyValue.prototype.getValueLength = function () {\n  return Bytes.toInt(this.bytes, this.offset + Bytes.SIZEOF_INT);\n};\n\n/**\n * @return Row offset\n */\nKeyValue.prototype.getRowOffset = function () {\n  return this.getKeyOffset() + Bytes.SIZEOF_SHORT;\n};\n\n/**\n * @return Row length\n */\nKeyValue.prototype.getRowLength = function () {\n  return Bytes.toShort(this.bytes, this.getKeyOffset());\n};\n\n/**\n * @return Family offset\n */\nKeyValue.prototype.getFamilyOffset = function (rlength) {\n  rlength = rlength || this.getRowLength();\n  // row offset + rowlength data(2 bytes) + rowlength + familylength data(1 byte)\n  return this.offset + KeyValue.ROW_OFFSET + Bytes.SIZEOF_SHORT + rlength + Bytes.SIZEOF_BYTE;\n};\n\n/**\n * @return Family length\n */\nKeyValue.prototype.getFamilyLength = function (familyOffset) {\n  familyOffset = familyOffset || this.getFamilyOffset();\n  return this.bytes[familyOffset - 1];\n};\n\n/**\n * @return Qualifier offset\n */\nKeyValue.prototype.getQualifierOffset = function (familyOffset) {\n  familyOffset = familyOffset || this.getFamilyOffset();\n  return familyOffset + this.getFamilyLength(familyOffset);\n};\n\n/**\n * @return Qualifier length\n */\nKeyValue.prototype.getQualifierLength = function (rlength, flength) {\n  rlength = rlength || this.getRowLength();\n  flength = flength || this.getFamilyLength();\n  return this.getKeyLength() - (KeyValue.KEY_INFRASTRUCTURE_SIZE + rlength + flength);\n};\n\n/**\n * @return Column (family + qualifier) length\n */\nKeyValue.prototype.getTotalColumnLength = function (rlength, foffset) {\n  rlength = rlength || this.getRowLength();\n  foffset = foffset || this.getFamilyOffset(rlength);\n  var flength = this.getFamilyLength(foffset);\n  var qlength = this.getQualifierLength(rlength, flength);\n  return flength + qlength;\n};\n\n/**\n * @param keylength Pass if you have it to save on a int creation.\n * @return Timestamp offset\n */\nKeyValue.prototype.getTimestampOffset = function (keylength) {\n  keylength = keylength || this.getKeyLength();\n  return this.getKeyOffset() + keylength - KeyValue.TIMESTAMP_TYPE_SIZE;\n};\n\n/**\n * @return True if this KeyValue has a LATEST_TIMESTAMP timestamp.\n */\nKeyValue.prototype.isLatestTimestamp = function () {\n  return Bytes.equals(this.getBuffer(), this.getTimestampOffset(), Bytes.SIZEOF_LONG, \n    HConstants.LATEST_TIMESTAMP_BYTES, 0, Bytes.SIZEOF_LONG);\n};\n\n/**\n * Do not use unless you have to.  Used internally for compacting and testing.\n *\n * Use {@link #getRow()}, {@link #getFamily()}, {@link #getQualifier()}, and\n * {@link #getValue()} if accessing a KeyValue client-side.\n * @return Copy of the key portion only.\n */\nKeyValue.prototype.getKey = function () {\n  var keyLength = this.getKeyLength();\n  var offset = this.getKeyOffset();\n  return this.bytes.slice(offset, offset + keyLength);\n};\n\n/**\n * Returns value in a new byte array.\n * Primarily for use client-side. If server-side, use\n * {@link #getBuffer()} with appropriate offsets and lengths instead to\n * save on allocations.\n * @return Value in a new byte array.\n */\nKeyValue.prototype.getValue = function () {\n  var o = this.getValueOffset();\n  var l = this.getValueLength();\n  return this.getBuffer().slice(o, o + l);\n};\n\n/**\n * Primarily for use client-side.  Returns the row of this KeyValue in a new\n * byte array.<p>\n *\n * If server-side, use {@link #getBuffer()} with appropriate offsets and\n * lengths instead.\n * @return Row in a new byte array.\n */\nKeyValue.prototype.getRow = function () {\n  if (this.rowCache === null) {\n    var o = this.getRowOffset();\n    var l = this.getRowLength();\n    // initialize and copy the data into a local variable\n    // in case multiple threads race here.\n    this.rowCache = this.getBuffer().slice(o, o + l);\n  }\n  return this.rowCache;\n};\n\nKeyValue.prototype.getTimestamp = function () {\n  if (this.timestampCache === -1) {\n    var tsOffset = this.getTimestampOffset();\n    this.timestampCache = WritableUtils.toLong(this.bytes.slice(tsOffset, tsOffset + Bytes.SIZEOF_LONG));\n  }\n  return this.timestampCache;\n};\n\n/**\n * @param keylength Pass if you have it to save on a int creation.\n * @return Type of this KeyValue.\n */\nKeyValue.prototype.getType = function (keylength) {\n  keylength = keylength || this.getKeyLength();\n  return this.bytes[this.offset + keylength - 1 + KeyValue.ROW_OFFSET];\n};\n\n/**\n * Primarily for use client-side.  Returns the family of this KeyValue in a\n * new byte array.<p>\n *\n * If server-side, use {@link #getBuffer()} with appropriate offsets and\n * lengths instead.\n * @return Returns family. Makes a copy.\n */\nKeyValue.prototype.getFamily = function () {\n  var o = this.getFamilyOffset();\n  var l = this.getFamilyLength(o);\n  return this.bytes.slice(o, o + l);\n};\n\n/**\n * Primarily for use client-side.  Returns the column qualifier of this\n * KeyValue in a new byte array.<p>\n *\n * If server-side, use {@link #getBuffer()} with appropriate offsets and\n * lengths instead.\n * Use {@link #getBuffer()} with appropriate offsets and lengths instead.\n * @return Returns qualifier. Makes a copy.\n */\nKeyValue.prototype.getQualifier = function () {\n  var o = this.getQualifierOffset();\n  var l = this.getQualifierLength();\n  return this.bytes.slice(o, o + l);\n};\n\nKeyValue.Type = Type;\n\nKeyValue.createKeyValue = function (row, family, qualifier, timestamp, type, value) {\n  var rlength = row.length;\n  // Family length\n  var flength = family ? family.length : 0;\n  // Qualifier length\n  var qlength = qualifier ? qualifier.length : 0;\n  // Key length\n  var keylength = KeyValue.KEY_INFRASTRUCTURE_SIZE + rlength + flength + qlength;\n  // Value length\n  var vlength = value ? value.length : 0;\n  // Allocate right-sized byte array.\n  var bytes = new Buffer(KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE + keylength + vlength);\n  // Write key, value and key row length.\n  var pos = 0;\n  pos = Bytes.putInt(bytes, pos, keylength);\n  pos = Bytes.putInt(bytes, pos, vlength);\n  pos = Bytes.putShort(bytes, pos, rlength);\n  pos = Bytes.putBytes(bytes, pos, row);\n  pos = Bytes.putByte(bytes, pos, flength);\n  if (flength !== 0) {\n    pos = Bytes.putBytes(bytes, pos, family);\n  }\n  if (qlength !== 0) {\n    pos = Bytes.putBytes(bytes, pos, qualifier);\n  }\n  pos = Bytes.putLong(bytes, pos, timestamp);\n  pos = Bytes.putByte(bytes, pos, type);\n  if (value && value.length > 0) {\n    pos = Bytes.putBytes(bytes, pos, value);\n  }\n\n  return new KeyValue(bytes);\n};\n\nKeyValue.prototype.write = function (out) {\n  out.writeInt(this.getLength());\n  out.write(this.getBuffer(), this.getOffset(), this.getLength());\n};\n\n\nmodule.exports = KeyValue;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/hconstants.js":"/*!\n * node-hbase-client - lib/hconstants.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar Long = require('long');\nvar Bytes = require('./util/bytes');\n\nvar CONST = {};\n\nCONST.PROTOCOL = 'org.apache.hadoop.hbase.ipc.HRegionInterface';\nCONST.CLIENT_VERSION = Long.fromNumber(29);\n\n/**\n * Timestamp to use when we want to refer to the latest cell.\n * This is the timestamp sent by clients when no timestamp is specified on\n * commit.\n */\nCONST.LATEST_TIMESTAMP = Long.MAX_VALUE;\n/**\n * Timestamp to use when we want to refer to the oldest cell.\n */\nCONST.OLDEST_TIMESTAMP = Long.MIN_VALUE;\n/**\n * LATEST_TIMESTAMP in bytes form\n */\nCONST.LATEST_TIMESTAMP_BYTES = Bytes.toBytes(CONST.LATEST_TIMESTAMP);\n/** The root table's name.*/\nCONST.ROOT_TABLE_NAME = Bytes.toBytes(\"-ROOT-\");\nCONST.ROOT_TABLE_NAME.__name__ = '-ROOT-';\n\n/** The META table's name. */\nCONST.META_TABLE_NAME = Bytes.toBytes(\".META.\");\nCONST.META_TABLE_NAME.__name__ = '.META.';\n\n/** delimiter used between portions of a region name */\nCONST.META_ROW_DELIMITER = ',';\n\n/** The catalog family as a string*/\nCONST.CATALOG_FAMILY_STR = \"info\";\n\n/** The catalog family */\nCONST.CATALOG_FAMILY = Bytes.toBytes(CONST.CATALOG_FAMILY_STR);\n\n/** The regioninfo column qualifier */\nCONST.REGIONINFO_QUALIFIER = Bytes.toBytes(\"regioninfo\");\n\n/** The server column qualifier */\nCONST.SERVER_QUALIFIER = Bytes.toBytes(\"server\");\n\n/** The startcode column qualifier */\nCONST.STARTCODE_QUALIFIER = Bytes.toBytes(\"serverstartcode\");\n\n/** The lower-half split region column qualifier */\nCONST.SPLITA_QUALIFIER = Bytes.toBytes(\"splitA\");\n\n/** The upper-half split region column qualifier */\nCONST.SPLITB_QUALIFIER = Bytes.toBytes(\"splitB\");\n\n/**\n * The meta table version column qualifier.\n * We keep current version of the meta table in this column in <code>-ROOT-</code>\n * table: i.e. in the 'info:v' column.\n */\nCONST.META_VERSION_QUALIFIER = Bytes.toBytes(\"v\");\n\n/**\n * The current version of the meta table.\n * Before this the meta had HTableDescriptor serialized into the HRegionInfo;\n * i.e. pre-hbase 0.92.  There was no META_VERSION column in the root table\n * in this case.  The presence of a version and its value being zero indicates\n * meta is up-to-date.\n */\nCONST.META_VERSION = 0;\n\n/** long constant for zero */\n// CONST.ZERO_L = Long.valueOf(0L);\nCONST.NINES = \"99999999999999\";\nCONST.ZEROES = \"00000000000000\";\n\n// Other constants\n\n/**\n * An empty instance.\n */\nCONST.EMPTY_BYTE_ARRAY = new Buffer(0);\n\n/**\n * Used by scanners, etc when they want to start at the beginning of a region\n */\nCONST.EMPTY_START_ROW = CONST.EMPTY_BYTE_ARRAY;\n\n/**\n * Last row in a table.\n */\nCONST.EMPTY_END_ROW = CONST.EMPTY_START_ROW;\n\n/**\n* Used by scanners and others when they're trying to detect the end of a\n* table\n*/\nCONST.LAST_ROW = CONST.EMPTY_BYTE_ARRAY;\n\n/**\n * Parameter name for client prefetch limit, used as the maximum number of regions\n * info that will be prefetched.\n */\n// public static String HBASE_CLIENT_PREFETCH_LIMIT = \"hbase.client.prefetch.limit\";\n\n/**\n * Default value of {@link #HBASE_CLIENT_PREFETCH_LIMIT}.\n */\nCONST.DEFAULT_HBASE_CLIENT_PREFETCH_LIMIT = 10;\n\n/**\n * Parameter name for number of rows that will be fetched when calling next on\n * a scanner if it is not served from memory. Higher caching values will\n * enable faster scanners but will eat up more memory and some calls of next\n * may take longer and longer times when the cache is empty.\n */\nCONST.HBASE_META_SCANNER_CACHING = \"hbase.meta.scanner.caching\";\n\n/**\n * Default value of {@link #HBASE_META_SCANNER_CACHING}.\n */\nCONST.DEFAULT_HBASE_META_SCANNER_CACHING = 100;\n\n/**\n * Parameter name for maximum retries, used as maximum for all retryable\n * operations such as fetching of the root region from root region server,\n * getting a cell's value, starting a row update, etc.\n */\nCONST.DEFAULT_HBASE_CLIENT_RETRIES_NUMBER = 10;\n\n/**\n * timeout for each RPC\n */\nCONST.DEFAULT_HBASE_RPC_TIMEOUT = 30000; // 60000;\n\nCONST.DEFAULT_PING_INTERVAL = 30000;\n\nmodule.exports = CONST;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/scan.js":"/**!\n * node-hbase-client - lib/scan.js\n *\n * Copyright(c) 2013 - 2014 Alibaba Group Holding Limited.\n *\n * Authors:\n *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar util = require('util');\nvar OperationWithAttributes = require('./operation_with_attributes');\nvar Bytes = require('./util/bytes');\nvar HConstants = require('./hconstants');\nvar TimeRange = require('./time_range');\n\nvar RAW_ATTR = \"_raw_\";\nvar ISOLATION_LEVEL = \"_isolationlevel_\";\n// 0.94.16 SCAN_VERSION = (byte)2, but inside alibaba SCAN_VERSION = (byte) 6;\nvar SCAN_VERSION = 2;\n// If application wants to collect scan metrics, it needs to\n// call scan.setAttribute(SCAN_ATTRIBUTES_ENABLE, Bytes.toBytes(Boolean.TRUE))\nvar SCAN_ATTRIBUTES_METRICS_ENABLE = \"scan.attributes.metrics.enable\";\nvar SCAN_ATTRIBUTES_METRICS_DATA = \"scan.attributes.metrics.data\";\n\n/**\n * Create a Scan operation for the range of rows specified.\n *\n * @param [startRow] row to start scanner at or after (inclusive), defautl is `EMPTY_START_ROW`\n * @param [stopRow] row to stop scanner before (exclusive), defautl is `EMPTY_START_ROW`\n */\nfunction Scan(startRow, stopRow) {\n  OperationWithAttributes.call(this);\n\n  this.startRow = startRow || HConstants.EMPTY_START_ROW;\n  this.stopRow = stopRow || HConstants.EMPTY_END_ROW;\n  if (!Buffer.isBuffer(this.startRow)) {\n    this.startRow = Bytes.toBytes(this.startRow);\n  }\n  if (!Buffer.isBuffer(this.stopRow)) {\n    this.stopRow = Bytes.toBytes(this.stopRow);\n  }\n\n  this.maxVersions = 1;\n  this.batch = -1;\n\n  /*\n   * -1 means no caching\n   */\n  this.caching = -1;\n  this.maxResultSize = -1;\n  this.cacheBlocks = true;\n  this.filter = null;\n  this.tr = new TimeRange();\n  this.familyMap = {};\n}\n\nutil.inherits(Scan, OperationWithAttributes);\n\nScan.prototype.getRow = function () {\n  return this.startRow;\n};\n\n/**\n * Get all columns from the specified family.\n * <p>\n * Overrides previous calls to addColumn for this family.\n * @param family family name\n * @return this\n */\nScan.prototype.addFamily = function (family) {\n  this.familyMap[family] = null;\n  return this;\n};\n\n/**\n * Get the column from the specified family with the specified qualifier.\n * <p>\n * Overrides previous calls to addFamily for this family.\n * @param family family name\n * @param qualifier column qualifier\n * @return this\n */\nScan.prototype.addColumn = function (family, qualifier) {\n  var set = this.familyMap[family];\n  if (!set) {\n    this.familyMap[family] = set = [];\n  }\n  set.push(qualifier);\n  return this;\n};\n\n/**\n * Get versions of columns only within the specified timestamp range,\n * [minStamp, maxStamp).  Note, default maximum versions to return is 1.  If\n * your time range spans more than one version and you want all versions\n * returned, up the number of versions beyond the defaut.\n * @param minStamp minimum timestamp value, inclusive\n * @param maxStamp maximum timestamp value, exclusive\n * @throws IOException if invalid time range\n * @see #setMaxVersions()\n * @see #setMaxVersions(int)\n * @return this\n */\nScan.prototype.setTimeRange = function (minStamp, maxStamp) {\n  this.tr = new TimeRange(minStamp, maxStamp);\n  return this;\n};\n\n/**\n * Get versions of columns with the specified timestamp. Note, default maximum\n * versions to return is 1.  If your time range spans more than one version\n * and you want all versions returned, up the number of versions beyond the\n * defaut.\n * @param timestamp version timestamp\n * @see #setMaxVersions()\n * @see #setMaxVersions(int)\n * @return this\n */\nScan.prototype.setTimeStamp = function (timestamp) {\n  this.tr = new TimeRange(timestamp, timestamp + 1);\n  return this;\n};\n\n/**\n * Apply the specified server-side filter when performing the Scan.\n * @param filter filter to run on the server\n * @return this\n */\nScan.prototype.setFilter = function (filter) {\n  this.filter = filter;\n  return this;\n};\n\nScan.prototype.write = function (out) {\n  out.writeByte(SCAN_VERSION);\n  Bytes.writeByteArray(out, this.startRow);\n  Bytes.writeByteArray(out, this.stopRow);\n  out.writeInt(this.maxVersions);\n  out.writeInt(this.batch);\n  out.writeInt(this.caching);\n  out.writeBoolean(this.cacheBlocks);\n  if (!this.filter) {\n    out.writeBoolean(false);\n  } else {\n    out.writeBoolean(true);\n    Bytes.writeByteArray(out, Bytes.toBytes(this.filter.constructor.classname));\n    this.filter.write(out);\n  }\n  this.tr.write(out);\n  out.writeInt(Object.keys(this.familyMap).length);\n  for (var family in this.familyMap) {\n    Bytes.writeByteArray(out, Bytes.toBytes(family));\n    var columnSet = this.familyMap[family];\n    if (columnSet && columnSet.length > 0) {\n      out.writeInt(columnSet.length);\n      for (var i = 0; i < columnSet.length; i++) {\n        var qualifier = columnSet[i];\n        Bytes.writeByteArray(out, Bytes.toBytes(qualifier));\n      }\n    } else {\n      out.writeInt(0);\n    }\n  }\n  this.writeAttributes(out);\n  out.writeLong(this.maxResultSize);\n};\n\n\nmodule.exports = Scan;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/result.js":"/*!\n * node-hbase-client - lib/result.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar Bytes = require('./util/bytes');\nvar HbaseObjectWritable = require('./io/hbase_object_writable');\nvar KeyValue = require('./keyvalue');\nvar errors = require('./errors');\nvar RESULT_VERSION = 1;\n\nfunction Result(bytes) {\n  if (!(this instanceof Result)) {\n    return new Result();\n  }\n  this.kvs = null;\n  this.familyMap = null;\n  // We're not using java serialization.  Transient here is just a marker to say\n  // that this is where we cache row if we're ever asked for it.\n  this.row = null;\n  this.bytes = bytes || null;\n}\n\nResult.prototype.readFields = function (io) {\n  this.familyMap = null;\n  this.row = null;\n  this.kvs = null;\n  var totalBuffer = io.readInt();\n  if (totalBuffer === 0) {\n    this.bytes = null;\n    return;\n  }\n  var raw = io.read(totalBuffer);\n  this.bytes = raw;\n};\n\nResult.prototype._readFields = function () {\n  if (this.bytes === null) {\n    this.kvs = [];\n    return;\n  }\n  var buf = this.bytes;\n  var offset = 0;\n  var finalOffset = buf.length;\n  var kvs = [];\n  while (offset < finalOffset) {\n    var keyLength = Bytes.toInt(buf, offset);\n    offset += Bytes.SIZEOF_INT;\n    kvs.push(new KeyValue(buf, offset, keyLength));\n    offset += keyLength;\n  }\n  this.kvs = kvs;\n};\n\nResult.prototype.raw = function () {\n  if (this.kvs === null) {\n    this._readFields();\n  }\n  return this.kvs;\n};\n\nResult.prototype.size = function () {\n  return this.raw().length;\n};\n\n/**\n * Get the latest version of the specified column.\n * @param family family name\n * @param qualifier column qualifier\n * @return value of latest version of column, null if none found\n */\nResult.prototype.getValue = function (family, qualifier) {\n  var kv = this.getColumnLatest(family, qualifier);\n  if (kv === null) {\n    return null;\n  }\n  return kv.getValue();\n};\n\n/**\n * Return the KeyValues for the specific column.  The KeyValues are sorted in\n * the {@link KeyValue#COMPARATOR} order.  That implies the first entry in\n * the list is the most recent column.  If the query (Scan or Get) only\n * requested 1 version the list will contain at most 1 entry.  If the column\n * did not exist in the result set (either the column does not exist\n * or the column was not selected in the query) the list will be empty.\n *\n * Also see getColumnLatest which returns just a KeyValue\n *\n * @param {byte[]} family the family\n * @param {byte[]} qualifier\n * @return a list of KeyValues for this column or empty list if the column\n * did not exist in the result set\n */\nResult.prototype.getColumn = function (family, qualifier) {\n  if (family !== null && !Buffer.isBuffer(family)) {\n    family = Bytes.toBytes(family);\n  }\n  if (qualifier !== null && !Buffer.isBuffer(qualifier)) {\n    qualifier = Bytes.toBytes(qualifier);\n  }\n  var result = [];\n  var kvs = this.raw();\n  if (!kvs || kvs.length === 0) {\n    return result;\n  }\n  for (var i = 0; i < kvs.length; i++) {\n    var kv = kvs[i];\n    if (!Bytes.equals(kv.getFamily(), family)) {\n      continue;\n    }\n    if (!Bytes.equals(kv.getQualifier(), qualifier)) {\n      continue;\n    }\n    result.push(kv);\n  }\n  return result;\n};\n\n/**\n * The KeyValue for the most recent for a given column. If the column does\n * not exist in the result set - if it wasn't selected in the query (Get/Scan)\n * or just does not exist in the row the return value is null.\n *\n * @param family\n * @param qualifier\n * @return KeyValue for the column or null\n */\nResult.prototype.getColumnLatest = function (family, qualifier) {\n  var kvs = this.raw(); // side effect possibly.\n  if (!kvs || kvs.length === 0) {\n    return null;\n  }\n\n  family = Bytes.toBytes(family);\n  qualifier = Bytes.toBytes(qualifier);\n\n  for (var i = 0; i < kvs.length; i++) {\n    var kv = kvs[i];\n    if (!Bytes.equals(kv.getFamily(), family)) {\n      continue;\n    }\n    if (!Bytes.equals(kv.getQualifier(), qualifier)) {\n      continue;\n    }\n    return kv;\n  }\n  // var pos = this.binarySearch(kvs, family, qualifier);\n  // if (pos === -1) {\n  //   return null;\n  // }\n  // var kv = kvs[pos];\n  // if (kv.matchingColumn(family, qualifier)) {\n  //   return kv;\n  // }\n  return null;\n};\n\n/**\n * Method for retrieving the row key that corresponds to\n * the row from which this Result was created.\n * @return row\n */\nResult.prototype.getRow = function () {\n  if (this.row === null) {\n    this.raw();\n    this.row = this.kvs.length === 0 ? null: this.kvs[0].getRow();\n  }\n  return this.row;\n};\n\nResult.readArray = function (io) {\n  // Read version for array form.\n  // This assumes that results are sent to the client as Result[], so we\n  // have an opportunity to handle version differences without affecting\n  // efficiency.\n  var version = io.readByte();\n  if (version > RESULT_VERSION) {\n    throw new errors.IOException(\"version not supported\");\n  }\n  var numResults = io.readInt();\n  if (numResults === 0) {\n    return [];\n  }\n  var results = [];\n  var bufSize = io.readInt();\n  var buf = new Buffer(bufSize);\n  var offset = 0;\n  for (var i = 0; i < numResults; i++) {\n    var numKeys = io.readInt();\n    offset += Bytes.SIZEOF_INT;\n    if (numKeys === 0) {\n      results[i] = null;\n      continue;\n    }\n    var initialOffset = offset;\n    for (var j = 0; j < numKeys; j++) {\n      var keyLen = io.readInt();\n      Bytes.putInt(buf, offset, keyLen);\n      offset += Bytes.SIZEOF_INT;\n      var bytes = io.read(keyLen);\n      // console.log(keyLen, bytes)\n      Bytes.putBytes(buf, offset, bytes);\n      // io.readFully(buf, offset, keyLen);\n      offset += keyLen;\n    }\n    var totalLength = offset - initialOffset;\n    results[i] = new Result(buf.slice(initialOffset, initialOffset + totalLength));\n  }\n  return results;\n};\n\nResult.prototype.list = Result.prototype.raw;\n\n\nHbaseObjectWritable.addToClass('Result.class', Result);\nmodule.exports = Result;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/client.js":"/**!\n * node-hbase-client - lib/client.js\n *\n * Copyright(c) Alibaba Group Holding Limited.\n * MIT Licensed\n *\n * Authors:\n *   苏千 <suqian.yf@alibaba-inc.com> (http://fengmk2.github.com)\n */\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('hbase:client');\nvar EventEmitter = require('events').EventEmitter;\nvar ZooKeeperWatcher = require('zookeeper-watcher');\nvar util = require('util');\nvar Bytes = require('./util/bytes');\nvar DataOutputBuffer = require('./data_output_buffer');\nvar DataInputBuffer = require('./data_input_buffer');\nvar HConstants = require('./hconstants');\nvar Connection = require('./connection');\nvar errors = require('./errors');\nvar TableNotFoundException = errors.TableNotFoundException;\nvar IOException = errors.IOException;\nvar Get = require('./get');\nvar Put = require('./put');\nvar Delete = require('./delete');\nvar Scanner = require('./scanner');\nvar Scan = require('./scan');\nvar utility = require('utility');\nvar MultiResponse = require('./multi_response');\nvar EventProxy = require('eventproxy');\nvar Pair = require('./pair');\nvar MultiAction = require('./multi_action');\nvar Action = require('./action');\nvar HRegionInfo = require('./hregion_info');\nvar HRegionLocation = require('./hregion_location');\n\n/**\n * This character is used as separator between server hostname, port and\n * startcode.\n */\nvar SERVERNAME_SEPARATOR = \",\";\n\nfunction Client(options) {\n  if (!(this instanceof Client)) {\n    return new Client(options);\n  }\n  EventEmitter.call(this);\n  this.rpcTimeout = options.rpcTimeout || HConstants.DEFAULT_HBASE_RPC_TIMEOUT;\n  this.in = null;\n  this.out = null;\n  this.socket = null;\n  this.logger = options.logger || console;\n  options.zookeeperRoot = options.zookeeperRoot || \"/hbase\";\n  if (options.zookeeper && typeof options.zookeeper.quorum === 'string') {\n    options.zookeeperHosts = options.zookeeper.quorum.split(SERVERNAME_SEPARATOR);\n  }\n  this.zk = new ZooKeeperWatcher({\n    hosts: options.zookeeperHosts,\n    root: options.zookeeperRoot,\n    logger: this.logger,\n  });\n\n  this.zkStart = 'init';\n  this.rootRegionZKPath = options.rootRegionZKPath || '/root-region-server';\n  this.numLocateRegionRetries = options.numLocateRegionRetries || 10;\n  // tablename: [region1, region2, ...],\n  this.cachedRegionLocations = {};\n  // {hostname:port: server, ...}\n  this.servers = {};\n  this.serversLength = 0;\n\n  // @wision: It makes sure that you prefetch the table only once at the time\n  // (if called multiple times, it stores callbacks and awaits emit).\n  this._prefetchRegionCacheList = {};\n\n  // The presence of a server in the map implies it's likely that there is an\n  // entry in cachedRegionLocations that map to this server; but the absence\n  // of a server in this map guarentees that there is no entry in cache that\n  // maps to the absent server.\n  this.cachedServers = {};\n\n  // region cache prefetch is enabled by default. this set contains all\n  // tables whose region cache prefetch are disabled.\n  this.regionCachePrefetchDisabledTables = {};\n\n  this.prefetchRegionLimit = options.prefetchRegionLimit || HConstants.DEFAULT_HBASE_CLIENT_PREFETCH_LIMIT;\n  this.numRetries = options.numRetries || HConstants.DEFAULT_HBASE_CLIENT_RETRIES_NUMBER;\n  this.maxActionRetries = options.maxActionRetries || 3;\n\n  this.ensureZookeeperTrackers(utility.noop);\n}\n\nutil.inherits(Client, EventEmitter);\n\nClient.create = function (options) {\n  return new Client(options);\n};\n\n\n// The metadata attached to each piece of data has the\n// format:\n//   <magic> 1-byte constant\n//   <id length> 4-byte big-endian integer (length of next field)\n//   <id> identifier corresponding uniquely to this process\n// It is prepended to the data supplied by the user.\n\n// the magic number is to be backward compatible\nvar MAGIC = 255;\nvar MAGIC_SIZE = Bytes.SIZEOF_BYTE;\nvar ID_LENGTH_OFFSET = MAGIC_SIZE;\nvar ID_LENGTH_SIZE = Bytes.SIZEOF_INT;\nfunction removeMetaData(data) {\n  if (data === null || data.length === 0) {\n    return data;\n  }\n  // check the magic data; to be backward compatible\n  var magic = data[0];\n  if (magic !== MAGIC) {\n    return data;\n  }\n\n  var idLength = Bytes.toInt(data, ID_LENGTH_OFFSET);\n  var dataLength = data.length - MAGIC_SIZE - ID_LENGTH_SIZE - idLength;\n  var dataOffset = MAGIC_SIZE + ID_LENGTH_SIZE + idLength;\n\n  return data.slice(dataOffset, dataOffset + dataLength);\n}\nClient.removeMetaData = removeMetaData;\n\n/**\n * Extracts certain cells from a given row.\n * @param get The object that specifies what data to fetch and from which row.\n * @return The data coming from the specified row, if it exists.  If the row\n * specified doesn't exist, the {@link Result} instance returned won't\n * contain any {@link KeyValue}, as indicated by {@link Result#isEmpty()}.\n * @throws IOException if a remote or network exception occurs.\n * @since 0.20.0\n */\nClient.prototype.get = function (tableName, get, callback) {\n  this._action('get', tableName, get, true, 0, callback);\n};\n\nClient.prototype.checkAndPut = function (tableName, row, family, qualifier, value, put, callback) {\n  var _row = {\n    getRow: function() {\n      return row;\n    },\n    getFamily: function() { return family; },\n    getQualifier: function() { return qualifier; },\n    getValue: function() { return value; },\n    getPut: function() { return put; }\n  };\n  this._action('checkAndPut', tableName, _row, callback);\n};\n\nClient.prototype.put = function (tableName, put, callback) {\n  this._action('put', tableName, put, true, 0, callback);\n};\n\nClient.prototype.delete = function (tableName, del, callback) {\n  this._action('delete', tableName, del, true, 0, callback);\n};\n\n\nClient.prototype.getScanner = function (tableName, scan, callback) {\n  this._action('openScanner', tableName, scan, true, 0, function (err, scannerId, server) {\n    if (err) {\n      return callback(err);\n    }\n    var scanner = new Scanner(server, scannerId);\n    callback(null, scanner);\n  });\n};\n\nvar _CACHE_TABLES = {};\n\nfunction isRetryException(err) {\n  var errName = err.name.toLowerCase();\n  return errName.indexOf('org.apache.hadoop.hbase.') >= 0\n    || errName.indexOf('offline') >= 0\n    || errName.indexOf('noserver') >= 0\n    || errName.indexOf('notserving') >= 0;\n}\n\nClient.prototype._action = function (method, tableName, obj, useCache, retry, callback) {\n  retry = retry || 0;\n  debug('action %s, useCache: %s, retry: %s', method, useCache, retry);\n  if (!Buffer.isBuffer(tableName)) {\n    tableName = _CACHE_TABLES[tableName] || new Buffer(tableName);\n    _CACHE_TABLES[tableName] = tableName;\n  }\n  var row = obj.getRow();\n  var self = this;\n  self.locateRegion(tableName, row, useCache, function (err, location) {\n    if (err || !location) {\n      return callback(err);\n    }\n\n    self.getRegionConnection(location.getHostname(), location.getPort(), function (err, server) {\n      if (err) {\n        return callback(err);\n      }\n\n      server[method](location.getRegionInfo().getRegionName(), obj, function (err, value) {\n        // org.apache.hadoop.hbase.regionserver.WrongRegionException retry\n        if (err && isRetryException(err)) {\n          retry++;\n          self.logger.warn('[%s] [worker:%s] %s', Date(), process.pid, err.stack);\n          if (retry <= self.maxActionRetries) {\n            // max retries\n            self.logger.warn('[%s] [worker:%s] [%s] %s retries %s table row %s got wrong region: %s',\n              Date(), process.pid, method, retry, tableName, row.toString(), location.toString());\n            return utility.setImmediate(self._action.bind(self, method, tableName, obj, false, retry, callback));\n          }\n        }\n\n        callback(err, value, server);\n      });\n\n    });\n  });\n};\n\n/**\n * Parameterized batch processing, allowing varying return types for\n * different {@link Row} implementations.\n * @param {byte []} tableName\n */\nClient.prototype.processBatch = function (tableName, workingList, useCache, retry, callback) {\n  var self = this;\n  var actionsByServer = {};\n\n  // remove empty\n  var requestObjects = [];\n  for (var i = 0; i < workingList.length; i++) {\n    var item = workingList[i];\n    if (!item) {\n      continue;\n    }\n    requestObjects.push(item);\n  }\n\n  if (requestObjects.length === 0) {\n    return callback(null, []);\n  }\n\n  var ep = EventProxy.create();\n  ep.fail(callback);\n  ep.after('multi_action', workingList.length, function () {\n    // step 2: make the requests\n    var requestSize = Object.keys(actionsByServer).length;\n    if (debug.enabled) {\n      debug('multi_action: Caculate regionServer: %d %d \\n %s',\n        workingList.length, requestSize, Object.keys(actionsByServer).join('\\n'));\n    }\n\n    var results = [];\n    var totalExceptionCount = 0;\n    var retryException = null;\n    ep.after('request_done', requestSize, function () {\n      debug('processBatch got %d results, including %d exceptions',\n        results.length, totalExceptionCount);\n      if (retryException) {\n        // org.apache.hadoop.hbase.regionserver.WrongRegionException retry\n        retry++;\n        if (retry <= self.maxActionRetries) {\n          self.logger.warn('[%s] [worker:%s] %s', Date(), process.pid, retryException.message);\n          self.logger.warn('[%s] [worker:%s] processBatch %s retries on table %s',\n            Date(), process.pid, retry, tableName);\n          return utility.setImmediate(self.processBatch.bind(self, tableName, workingList, false, retry, callback));\n        }\n        // max retry\n        return callback(retryException, results);\n      }\n      callback(null, results);\n    });\n\n    // step 4: identify failures and prep for a retry (if applicable).\n    // TODO: retry for exceptions\n    // step 3: collect the failures and successes and prepare for retry\n    function processResult(value) {\n      if (!value) {\n        return;\n      }\n      for (var regionName in value.results) {\n        var regionResults = value.results[regionName];\n        for (var j = 0; j < regionResults.length; j++) {\n          var pair = regionResults[j];\n          if (!pair) {\n            // if the first/only record is 'null' the entire region failed.\n            // if (debug.enabled) {\n            //   debug('Failures for region: %s, removing from cache', regionName);\n            // }\n            continue;\n          }\n          var idx = pair.getFirst();\n          var result = pair.getSecond();\n          results[idx] = result;\n\n          // if (result.name === 'org.apache.hadoop.hbase.NotServingRegionException') {\n          //   delete self.cachedRegionLocations[Bytes.mapKey(regionName.split(',')[0])];\n          // }\n\n          if (result instanceof Error) {\n            totalExceptionCount++;\n            if (!retryException && isRetryException(result)) {\n              retryException = result;\n              if (debug.enabled) {\n                debug('Failures for region: %s, may be removing from cache, error: %s',\n                  regionName, retryException.message);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // step 2: make the requests\n    function makeRequest(location, multiAction) {\n      var hostname = location.getHostname();\n      var port = location.getPort();\n      self.getRegionConnection(hostname, port, ep.done(function (server) {\n        server.multi(multiAction, ep.done(function (value) {\n          processResult(value);\n          ep.emit('request_done');\n        }));\n      }));\n    }\n\n    for (var loc in actionsByServer) {\n      var action = actionsByServer[loc];\n      var location = action[0];\n      var mua = action[1];\n      makeRequest(location, mua);\n    }\n  });\n\n  // step 1: break up into regionserver-sized chunks and build the data structs\n  function buildDataStructs(row, i) {\n    self.locateRegion(tableName, row.getRow(), useCache, ep.done(function (loc) {\n      if (!loc) {\n        // TODO: retry\n        return ep.emit('multi_action');\n      }\n      var regionInfo = loc.getRegionInfo();\n      var key = regionInfo.regionNameStr;\n      var actions = actionsByServer[key];\n      if (!actions) {\n        actions = actionsByServer[key] = [loc, new MultiAction()];\n      }\n      var action = new Action(row, i);\n\n      actions[1].add(regionInfo, action);\n      ep.emit('multi_action');\n    }));\n  }\n\n  for (var i = 0; i < requestObjects.length; i++) {\n    buildDataStructs(requestObjects[i], i);\n  }\n};\n\n/**\n * Get a row with columns.\n *\n * @param {String|Buffer} tableName\n * @param {String|Buffer} row\n * @param {Array} [columns], column name, format: 'family:qualifier'.\n *   if `columns` not set or null or '*', will return all columns. like `select *`.\n *   e.g.: `['cf1:name', 'cf2:age', 'cf1:title']`\n * @param {Function(err, data)} callback\n */\nClient.prototype.getRow = function (tableName, row, columns, callback) {\n  var get = new Get(row);\n  if (typeof columns === 'function') {\n    callback = columns;\n    columns = null;\n  }\n  if (Array.isArray(columns) && columns.length > 0) {\n    for (var i = 0; i < columns.length; i++) {\n      var col = columns[i].split(':');\n      get.addColumn(col[0], col[1]);\n    }\n  }\n  this.get(tableName, get, function (err, result) {\n    if (err || !result) {\n      return callback(err, result);\n    }\n    var r = null;\n    var kvs = result.raw();\n    if (kvs.length > 0) {\n      r = {};\n      for (var i = 0; i < kvs.length; i++) {\n        var kv = kvs[i];\n        r[kv.getFamily().toString() + ':' + kv.getQualifier().toString()] = kv.getValue();\n      }\n    }\n    callback(null, r);\n  });\n};\n\n/**\n * Get rows with columns.\n *\n * @param {String|Buffer} tableName\n * @param {List<String|Buffer>} row\n * @param {Array} columns, column name, format: 'family:qualifier'.\n *   e.g.: `['cf1:name', 'cf2:age', 'cf1:title']`\n * @param {Object} opts, e.g.: `{raw: true}`\n * @param {Function(err, data)} callback\n */\nClient.prototype.mget = function (tableName, rows, columns, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var workingList = [];\n  for (var j = 0; j < rows.length; j++) {\n    var row = rows[j];\n    var get = new Get(row);\n    if (columns) {\n      for (var i = 0; i < columns.length; i++) {\n        var col = columns[i].split(':');\n        get.addColumn(col[0], col[1]);\n      }\n    }\n    workingList.push(get);\n  }\n  this.processBatch(tableName, workingList, true, 0, function (err, results) {\n    if (err) {\n      return callback(err);\n    }\n    for (var j = 0, len = results.length; j < len; j++) {\n      var data = results[j];\n      if (!data || data.constructor.name !== 'Result') {\n        results[j] = null;\n        // TODO: what's this?\n        continue;\n      }\n      var r = null;\n      if (opts.raw) {\n        results[j] = data;\n      } else {\n        var kvs = data.raw();\n        if (kvs.length > 0) {\n          r = {};\n          for (var i = 0; i < kvs.length; i++) {\n            var kv = kvs[i];\n            r[kv.getFamily().toString() + ':' + kv.getQualifier().toString()] = kv.getValue();\n          }\n        }\n        results[j] = r;\n      }\n    }\n    callback(null, results);\n  });\n};\n\n/**\n * put rows into table\n * @param  {String|Buffer} tableName\n * @param  {Array} rows [{row: 'aaabbbcccddd', 'f:name': 'xa', 'f:age': 1}]\n */\nClient.prototype.mput = function (tableName, rows, callback) {\n  if (!Array.isArray(rows)) {\n    return callback('Input rows must be an array.');\n  }\n  for (var i = 0, len = rows.length; i < len; i++) {\n    if (!(rows[i] instanceof Put) && !rows[i].row) {\n      return callback('Object must have property row or be instance of Put.');\n    }\n  }\n  var workingList = [];\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var data = rows[i];\n    var put = null;\n    if (data instanceof Put) {\n      put = data;\n    } else {\n      put = new Put(data.row, data.ts);\n      for (var k in data) {\n        if (k === 'row' || k === 'ts') {\n          continue;\n        }\n        var col = k.split(':');\n        put.add(col[0], col[1], data[k]);\n      }\n    }\n    workingList.push(put);\n  }\n  this.processBatch(tableName, workingList, true, 0, callback);\n};\n\n/**\n * delete rows from table\n * @param  {String|Buffer}  tableName\n * @param  {Array} rows ['aabbcc']\n */\nClient.prototype.mdelete = function (tableName, rows, callback) {\n  var workingList = [];\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n    var del = new Delete(row);\n    workingList.push(del);\n  }\n  this.processBatch(tableName, workingList, true, 0, callback);\n};\n\n/**\n * multi upsert. Put for values, Delete for null cells\n *\n * @param {String|Buffer} tableName\n * @param {Array} rows ['aabbcc']\n */\nClient.prototype.mupsert = function (tableName, rows, callback) {\n  var workingList = [];\n\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var data = rows[i];\n    var del = null;\n    var put = null;\n\n    for (var key in data) {\n      if (key === 'row' || key === 'ts') {\n        continue;\n      }\n      var col = key.split(':');\n      if (data[key] === null) { //content of qualifier is null\n        if (del === null) { // lazy create\n          del = new Delete(data.row, data.ts);\n        }\n        del.deleteColumn(col[0], col[1]);\n      } else {\n        if (put === null) { // lazy create\n          put = new Put(data.row, data.ts);\n        }\n        put.add(col[0], col[1], data[key]);\n      }\n    }\n\n    if (put !== null) {\n      workingList.push(put);\n    }\n    if (del !== null) {\n      workingList.push(del);\n    }\n  }\n\n  this.processBatch(tableName, workingList, true, 0, callback);\n};\n\n/**\n * Put a row to table.\n *\n * @param {String|Buffer} tableName\n * @param {String|Buffer} row\n * @param {Object} data, e.g.: `{'f1:name': 'foo', 'f1:age': '18'}`\n * @param {Function(err)} callback\n */\nClient.prototype.putRow = function (tableName, row, data, callback) {\n  var put = new Put(row);\n  for (var k in data) {\n    // 'f:q'\n    var col = k.split(':');\n    put.add(col[0], col[1], data[k]);\n  }\n  this.put(tableName, put, callback);\n};\n\n/**\n * Delete a row from table.\n *\n * @param {String|Buffer} tableName\n * @param {String|Buffer} row\n * @param {Function(err)} callback\n */\nClient.prototype.deleteRow = function (tableName, row, callback) {\n  var del = new Delete(row);\n  this.delete(tableName, del, callback);\n};\n\n/**\n * Find the location of the region of <i>tableName</i> that <i>row</i>\n * lives in.\n *\n * @param {Buffer|String} tableName, name of the table <i>row</i> is in\n * @param {Buffer|String} row, row key you're trying to find the region of\n * @param {Boolean} useCache default is true\n * @param {Function(err, location)} callback\n *  - {HRegionLocation} location, that describes where to find the region in question\n */\nClient.prototype.locateRegion = function (tableName, row, useCache, callback) {\n  if (typeof useCache === 'function') {\n    callback = useCache;\n    useCache = true;\n  }\n  if (!Buffer.isBuffer(tableName)) {\n    tableName = Bytes.toBytes(tableName);\n  }\n  if (row === null) {\n    row = new Buffer(0);\n  }\n  if (!Buffer.isBuffer(row)) {\n    row = Bytes.toBytes(row);\n  }\n\n  var self = this;\n  self.ensureZookeeperTrackers(function (err) {\n    // TODO: handle err\n    if (err) {\n      return callback(err);\n    }\n\n    if (Bytes.equals(tableName, HConstants.ROOT_TABLE_NAME)) {\n      var servername = self.rootServerName;\n      callback(null, new HRegionLocation(HRegionInfo.ROOT_REGIONINFO, servername.hostname, servername.port));\n    } else if (Bytes.equals(tableName, HConstants.META_TABLE_NAME)) {\n      self.locateRegionInMeta(HConstants.ROOT_TABLE_NAME, tableName, row, useCache, callback);\n    } else {\n      // Region not in the cache - have to go to the meta RS\n      self.locateRegionInMeta(HConstants.META_TABLE_NAME, tableName, row, useCache, callback);\n    }\n  });\n};\n\n/**\n * Find the location of the region of <i>tableName</i> that <i>row</i>\n * lives in, ignoring any value that might be in the cache.\n *\n * @param tableName name of the table <i>row</i> is in\n * @param row row key you're trying to find the region of\n * @return HRegionLocation that describes where to find the region in\n * question\n * @throws IOException if a remote or network exception occurs\n */\nClient.prototype.relocateRegion = function (tableName, row, callback) {\n  this.locateRegion(tableName, row, false, callback);\n};\n\nClient.prototype.ensureZookeeperTrackers = function (callback) {\n  var self = this;\n  if (self.zkStart === 'done') {\n    return callback();\n  }\n\n  self.once('ready', callback);\n\n  if (self.zkStart === 'starting') {\n    return;\n  }\n\n  self.zkStart = 'starting';\n  self.zk.once('connected', function (err) {\n    if (err) {\n      self.zkStart = 'error';\n      self.logger.warn('[%s] [worker:%s] [hbase-client] zookeeper connect error: %s',\n        Date(), process.pid, err.stack);\n      return self.emit('ready', err);\n    }\n    self.zk.unWatch(self.rootRegionZKPath);\n\n    self.zk.watch(self.rootRegionZKPath, function (err, value, zstat) {\n      var firstStart = self.zkStart !== 'done';\n      if (err) {\n        self.logger.warn('[%s] [worker:%s] [hbase-client] zookeeper watch error: %s',\n          Date(), process.pid, err.stack);\n        if (firstStart) {\n          // only first start fail will emit ready event\n          self.zkStart = 'error';\n          self.emit('ready', err);\n        }\n        return;\n      }\n\n      self.zkStart = 'done';\n      var rootServer = self.createServerName(value);\n      var oldRootServer = self.rootServerName;\n      self.rootServerName = rootServer;\n      self.logger.warn('[%s] [worker:%s] [hbase-client] zookeeper start done, got new root %s, old %s',\n        Date(), process.pid, rootServer.servername, oldRootServer ? oldRootServer.servername : null);\n      if (firstStart) {\n        // only first start success will emit ready event\n        self.emit('ready');\n      }\n    });\n  });\n};\n\nClient.prototype._syncRootRegion = function () {\n  var self = this;\n  self.zk.get(self.rootRegionZKPath, function (err, value, zstat) {\n    if (err) {\n      return self.logger.error(err);\n    }\n    var rootServer = self.createServerName(value);\n    var oldRootServer = self.rootServerName;\n    self.rootServerName = rootServer;\n    self.logger.warn('[%s] [worker:%s] [hbase-client] zookeeper start done, got new root %s, old %s',\n      Date(), process.pid, rootServer.servername, oldRootServer ? oldRootServer.servername : null);\n  });\n};\n\nClient.prototype._storeRegionInfo = function (regionInfoRow) {\n  var value = regionInfoRow.getValue(HConstants.CATALOG_FAMILY, HConstants.REGIONINFO_QUALIFIER);\n  if (!value || value.length === 0) {\n    return null;\n  }\n\n  // convert the row result into the HRegionLocation we need!\n  var io = new DataInputBuffer(value);\n  var regionInfo = new HRegionInfo();\n  regionInfo.readFields(io);\n\n  value = regionInfoRow.getValue(HConstants.CATALOG_FAMILY, HConstants.SERVER_QUALIFIER);\n  var hostAndPort = \"\";\n  if (value !== null) {\n    hostAndPort = Bytes.toString(value);\n  }\n\n  if (!hostAndPort) {\n    return null;\n  }\n\n  // Instantiate the location\n  var item = hostAndPort.split(':');\n  var hostname = item[0];\n  var port = parseInt(item[1], 10);\n\n  var location = new HRegionLocation(regionInfo, hostname, port);\n  return location;\n};\n\n/**\n  * Search one of the meta tables (-ROOT- or .META.) for the HRegionLocation\n  * info that contains the table and row we're seeking.\n  */\nClient.prototype.locateRegionInMeta = function (parentTable, tableName, row, useCache, callback, tries) {\n  debug('locateRegionInMeta, useCache: %s, tries: %s', useCache, tries);\n\n  if (!Buffer.isBuffer(tableName)) {\n    tableName = Bytes.toBytes(tableName);\n  }\n\n  var location;\n  // If we are supposed to be using the cache, look in the cache to see if\n  // we already have the region.\n  if (useCache) {\n    location = this.getCachedLocation(tableName, row);\n    if (location) {\n      return callback(null, location);\n    }\n  }\n\n  // build the key of the meta region we should be looking for.\n  // the extra 9's on the end are necessary to allow \"exact\" matches\n  // without knowing the precise region names.\n  var metaKey = HRegionInfo.createRegionName(tableName, row, HConstants.NINES, false);\n\n  var self = this;\n  var metaLocation = null;\n  // locate the root or meta region\n  self.locateRegion(parentTable, metaKey, false, function (err, metaLocation) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!metaLocation) {\n      // TODO: retries\n      return callback();\n    }\n\n    if (debug.enabled) {\n      debug('locateRegion %s:%s from %s(%s), current root: %s',\n        tableName.toString(), metaKey.toString(),\n        parentTable.toString(),\n        metaLocation.getHostnamePort(),\n        self.rootServerName.servername);\n    }\n\n    self.getRegionConnection(metaLocation.getHostname(), metaLocation.getPort(), function (err, server) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Check the cache again for a hit in case some other thread made the\n      // same query while we were waiting on the lock. If not supposed to\n      // be using the cache, delete any existing cached location so it won't\n      // interfere.\n\n      var location = null;\n      if (useCache) {\n        location = self.getCachedLocation(tableName, row);\n        if (location) {\n          return callback(null, location);\n        }\n      } else {\n        self.deleteCachedLocation(tableName, row);\n      }\n\n      // Query the root or meta region for the location of the meta region\n      server.getClosestRowBefore(metaLocation.getRegionInfo().getRegionName(), metaKey, HConstants.CATALOG_FAMILY,\n      function (err, regionInfoRow) {\n        if (err) {\n          if (Bytes.equals(tableName, HConstants.META_TABLE_NAME)) {\n            // locate meta error, try to reload root region meta\n            // make sure root change and zookeeper not working\n            self._syncRootRegion();\n          }\n\n          // Only relocate the parent region if necessary\n          if (isRetryException(err)) {\n            tries = tries || 0;\n            if (tries >= self.numRetries) {\n              return callback(err);\n            }\n            tries++;\n\n            self.logger.warn('[%s] [worker:%s] getClosestRowBefore error: %s', Date(), process.pid, err.stack);\n            self.logger.warn('[%s] [worker:%s] %s retries to locateRegion: %s',\n              Date(), process.pid, tries, metaKey.toString());\n            self.relocateRegion(parentTable, metaKey, function (err) {\n              if (err) {\n                return callback(err);\n              }\n\n              self.clearRegionCache(tableName);\n              // try again\n              self.locateRegionInMeta(parentTable, tableName, row, false, callback, tries);\n            });\n            return;\n          }\n\n          return callback(err);\n        }\n\n        if (regionInfoRow === null) {\n          return callback(new TableNotFoundException(\"Table '\" + Bytes.toString(tableName) + \"' was not found\"));\n        }\n\n        var location = self._storeRegionInfo(regionInfoRow);\n\n        if (!location) {\n          return callback(new IOException(\"HRegionInfo was null or empty in \" +\n            Bytes.toString(parentTable) + \", row=\" + regionInfoRow));\n        }\n\n        var regionInfo = location.regionInfo;\n\n        // possible we got a region of a different table...\n        if (!Bytes.equals(regionInfo.getTableName(), tableName)) {\n          return callback(new TableNotFoundException(\"Table '\" + Bytes.toString(tableName) +\n            \"' was not found, got: \" + Bytes.toString(regionInfo.getTableName()) + \".\"));\n        }\n        if (regionInfo.isSplit()) {\n          return callback(new errors.RegionOfflineException(\"the only available region for\"\n            + \" the required row is a split parent,\"\n            + \" the daughters should be online soon: \" + regionInfo));\n        }\n        if (regionInfo.isOffline()) {\n          return callback(new errors.RegionOfflineException(\n            \"the region is offline, could be caused by a disable table call: \" + regionInfo));\n        }\n\n        self.cacheLocation(tableName, location);\n\n        // If the parent table is META, we may want to pre-fetch some\n        // region info into the global region cache for this table.\n        if (Bytes.equals(parentTable, HConstants.META_TABLE_NAME)) {\n          var eventName = Buffer.concat([tableName, regionInfo.startKey]).toString();\n          // make sure only one request for the same region prefetch\n          if (self._prefetchRegionCacheList[eventName]) {\n            self.once(eventName, callback);\n            return;\n          }\n\n          self._prefetchRegionCacheList[eventName] = true;\n          self.prefetchRegionCache(tableName, regionInfo.startKey, function (err, count) {\n            self.logger.warn('[%s, startRow:%s] prefetchRegionCache %d locations',\n              tableName.toString(), regionInfo.startKey, count);\n            if (err) {\n              self.logger.warn('[prefetchRegionCache] error: %s', err.stack);\n            }\n\n            delete self._prefetchRegionCacheList[eventName];\n            self.emit(eventName, null, location);\n            callback(null, location);\n          });\n        } else {\n          callback(null, location);\n        }\n\n      });\n\n    });\n\n  });\n};\n\n/**\n * Get region connection.\n *\n * @param {String} hostname\n * @param {Number} port\n * @param {Function(err, server)} callback\n */\nClient.prototype.getRegionConnection = function (hostname, port, callback) {\n  var server;\n  var rsName = hostname + ':' + port;\n  var self = this;\n  // See if we already have a connection (common case)\n  server = self.servers[rsName];\n  var readyEvent = 'getRegionConnection:' + rsName + ':ready';\n  if (server && server.state === 'ready') {\n    debug('getRegionConnection from cache(%d), %s', self.serversLength, rsName);\n    return callback(null, server);\n  }\n\n  // debug('watting `%s` event', readyEvent);\n  self.once(readyEvent, callback);\n\n  if (server) {\n    return;\n  }\n\n  server = new Connection({\n    host: hostname,\n    port: port,\n    rpcTimeout: self.rpcTimeout,\n    logger: self.logger,\n  });\n  server.state = 'connecting';\n  // cache server\n  self.servers[rsName] = server;\n  self.serversLength++;\n\n  var timer = null;\n\n  var handleConnectionError = function handleConnectionError(err) {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n\n    self.clearCachedLocationForServer(rsName);\n    delete self.servers[rsName];\n    self.serversLength--;\n\n    // avoid 'close' and 'connect' event emit.\n    server.removeAllListeners();\n    server.close();\n\n    debug(err.message);\n    self.emit(readyEvent, err);\n  };\n\n  // handle connect timeout\n  timer = setTimeout(function () {\n    var err = new errors.ConnectionConnectTimeoutException(rsName + ' connect timeout, ' + self.rpcTimeout + ' ms');\n    handleConnectionError(err);\n  }, self.rpcTimeout);\n\n  server.once('connect', function () {\n    clearTimeout(timer);\n    timer = null;\n\n    // should getProtocolVersion() first to check version\n    server.getProtocolVersion(null, null, function (err, version) {\n      server.state = 'ready';\n\n      if (err) {\n        return self.emit(readyEvent, err);\n      }\n      version = version.toNumber();\n      debug('%s connected, protocol: %s, total %d connections', rsName, version, self.serversLength);\n\n      self.emit(readyEvent, null, server);\n    });\n  });\n\n  server.once('connectError', handleConnectionError);\n\n  // TODO: connection always emit close event?\n  server.once('close', self._handleConnectionClose.bind(self, rsName));\n};\n\nClient.prototype._handleConnectionClose = function (rsName) {\n  // TODO: connection always emit close event?\n  delete this.servers[rsName];\n  this.serversLength--;\n\n  // clean relation regions cache\n  this.clearCachedLocationForServer(rsName);\n  debug('%s closed, total %d connections', rsName, this.serversLength);\n};\n\n/**\n * Delete a cached location\n * @param tableName tableName\n * @param row\n */\nClient.prototype.deleteCachedLocation = function (tableName, row) {\n  var key = Bytes.mapKey(tableName);\n  var tableLocations = this.cachedRegionLocations[key];\n  if (!tableLocations || !tableLocations.length) {\n    return;\n  }\n\n  // start to examine the cache. we can only do cache actions\n  // if there's something in the cache for this table.\n  var needs = [];\n  for (var i = 0; i < tableLocations.length; i++) {\n    var location = tableLocations[i];\n    var r = Bytes.compareTo(row, location.regionInfo.startKey);\n    if (r < 0) {\n      needs.push(location);\n      continue;\n    }\n  }\n\n  this.cachedRegionLocations[key] = needs;\n};\n\n/*\n * Search the cache for a location that fits our table and row key.\n * Return null if no suitable region is located. TODO: synchronization note\n *\n * <p>TODO: This method during writing consumes 15% of CPU doing lookup\n * into the Soft Reference SortedMap.  Improve.\n *\n * @param tableName\n * @param row\n * @return Null or region location found in cache.\n */\nClient.prototype.getCachedLocation = function (tableName, row) {\n  var tableLocations = this.getTableLocations(tableName);\n\n  // start to examine the cache. we can only do cache actions\n  // if there's something in the cache for this table.\n  if (!tableLocations.length) {\n    return null;\n  }\n\n  for (var i = 0; i < tableLocations.length; i++) {\n    var location = tableLocations[i];\n    var startKey = location.regionInfo.startKey;\n    var endKey = location.regionInfo.endKey;\n    var r = Bytes.compareTo(row, startKey);\n    if (r >= 0) {\n      if (endKey.length === 0 || Bytes.compareTo(endKey, row) > 0) {\n        if (debug.enabled) {\n          debug('getCachedLocation hit(%d: %d): get location(%s)',\n            tableLocations.length, i, location.toString());\n        }\n\n        return location;\n      }\n    }\n  }\n\n  debug('getCachedLocation miss(%d)', tableLocations.length);\n  return null;\n\n  // var possibleRegion = tableLocations.get(row);\n  // if (possibleRegion !== null) {\n  //   return possibleRegion;\n  // }\n\n  // possibleRegion = tableLocations.lowerValueByKey(row);\n  // if (possibleRegion === null) {\n  //   return null;\n  // }\n\n  // // make sure that the end key is greater than the row we're looking\n  // // for, otherwise the row actually belongs in the next region, not\n  // // this one. the exception case is when the endkey is\n  // // HConstants.EMPTY_END_ROW, signifying that the region we're\n  // // checking is actually the last region in the table.\n  // var endKey = possibleRegion.getRegionInfo().getEndKey();\n  // if (Bytes.equals(endKey, HConstants.EMPTY_END_ROW)\n  //     || KeyValue.getRowComparator(tableName).compareRows(endKey, 0, endKey.length, row, 0, row.length) > 0) {\n  //   return possibleRegion;\n  // }\n\n  // // Passed all the way through, so we got nothin - complete cache miss\n  // return null;\n};\n\nClient.prototype.createServerName = function (data) {\n  data = removeMetaData(data);\n  var servername = Bytes.toString(data);\n  var items = servername.split(SERVERNAME_SEPARATOR);\n  var address = {\n    hostname: items[0],\n    port: parseInt(items[1], 10),\n    startcode: Number(items[2]),\n    servername: servername\n  };\n\n  // servername maybe: \"xxxxx.cm6:60020\"\n  if (isNaN(address.port) && address.hostname.indexOf(':')) {\n    items = address.hostname.split(':');\n    address.hostname = items[0];\n    address.port = parseInt(items[1], 10);\n  }\n\n  debug('createServerName(%j) => %j', servername, address);\n  return address;\n};\n\n/*\n * Delete all cached entries of a table that maps to a specific location.\n *\n * @param hostnamePort\n */\nClient.prototype.clearCachedLocationForServer = function (hostnamePort) {\n  var deletedCount = 0;\n  if (!this.cachedServers[hostnamePort]) {\n    return;\n  }\n\n  for (var key in this.cachedRegionLocations) {\n    var locations = this.cachedRegionLocations[key];\n    var needs = [];\n    var deleted = false;\n    for (var i = 0; i < locations.length; i++) {\n      var location = locations[i];\n      if (location.getHostnamePort() === hostnamePort) {\n        deletedCount++;\n        deleted = true;\n      } else {\n        needs.push(location);\n      }\n    }\n    if (deleted) {\n      this.cachedRegionLocations[key] = needs;\n    }\n  }\n\n  delete this.cachedServers[hostnamePort];\n  this.logger.warn(\"Removed %d cached region locations that map to `%s`\", deletedCount, hostnamePort);\n};\n\n/*\n * @param tableName\n * @return Map of cached locations for passed <code>tableName</code>\n */\nClient.prototype.getTableLocations = function (tableName) {\n  // find the map of cached locations for this table\n  var key = tableName.__key;\n  if (!key) {\n    key = tableName.__key = Bytes.mapKey(tableName);\n  }\n  var result = this.cachedRegionLocations[key];\n  if (!result) {\n    this.cachedRegionLocations[key] = result = [];\n  }\n  return result;\n};\n\n/*\n * Put a newly discovered HRegionLocation into the cache.\n */\nClient.prototype.cacheLocation = function (tableName, location) {\n  // TODO: remove location when it split and offline\n  var tableLocations = this.getTableLocations(tableName);\n  for (var i = 0; i < tableLocations.length; i++) {\n    var o = tableLocations[i];\n    if (location.regionInfo.compareTo(o.regionInfo) === 0) {\n      // if location exists, do not cache it.\n      return;\n    }\n  }\n\n  this.cachedServers[location.getHostnamePort()] = true;\n  tableLocations.push(location);\n};\n\nClient.prototype.clearRegionCache = function (tableName) {\n  if (tableName) {\n    var key = tableName.__key;\n    if (!key) {\n      key = tableName.__key = Bytes.mapKey(tableName);\n    }\n    if (debug.enabled) {\n      debug('clearRegionCache %s: %d cache regions, cache key: %s',\n        tableName.toString(),\n        this.cachedRegionLocations[key] ? this.cachedRegionLocations[key].length : 0,\n        key);\n    }\n    this.cachedRegionLocations[key] = [];\n  } else {\n    this.cachedRegionLocations = {};\n  }\n  this.cachedServers = {};\n};\n\n/*\n * Search .META. for the HRegionLocation info that contains the table and\n * row we're seeking. It will prefetch certain number of regions info and\n * save them to the global region cache.\n */\nClient.prototype.prefetchRegionCache = function (tableName, row, callback) {\n  // Implement a new visitor for MetaScanner, and use it to walk through\n  // the .META.\n  var self = this;\n  var startRow = HRegionInfo.createRegionName(tableName, row, HConstants.ZEROES, false);\n  var scan = new Scan(startRow);\n  scan.addFamily(HConstants.CATALOG_FAMILY);\n  self.getScanner(HConstants.META_TABLE_NAME, scan, function (err, scanner) {\n    var count = 0;\n    var done = function (error) {\n      if (scanner) {\n        scanner.close(function () {\n          callback(error, count);\n        });\n      } else {\n        callback(error, count);\n      }\n    };\n\n    if (err) {\n      return done(err);\n    }\n\n    var next = function (numberOfRows) {\n      scanner.next(numberOfRows, function (err, rows) {\n        if (err) {\n          return done(err);\n        }\n        if (!rows || rows.length === 0) {\n          return done();\n        }\n        var closed = false;\n        rows.forEach(function (regionInfoRow) {\n          var location = self._storeRegionInfo(regionInfoRow);\n          if (!location || !Bytes.equals(location.regionInfo.tableName, tableName)) {\n            self.logger.warn('[%s] [worker:%s] [hbase-client] prefetchRegionCache %s empty',\n              Date(), process.pid, Bytes.toString(tableName));\n            closed = true;\n            return false;\n          }\n\n          var regionInfo = location.regionInfo;\n\n          if (regionInfo.isSplit()) {\n            return;\n          }\n          if (regionInfo.isOffline()) {\n            return;\n          }\n\n          count++;\n          self.cacheLocation(tableName, location);\n        });\n\n        if (closed) {\n          return done();\n        }\n\n        next(numberOfRows);\n      });\n    };\n    next(10);\n  });\n};\n\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/data_output_buffer.js":"/*!\n * node-hbase-client - lib/data_output_buffer.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar util = require('util');\nvar Long = require('long');\nvar DataOutputStream = require('./data_output_stream');\n\n\nfunction DataBuffer() {\n  this.datas = [];\n  this.length = 0;\n}\n\nDataBuffer.prototype.write = function (b) {\n  this.datas.push(b);\n  this.length += b.length;\n};\n\nfunction DataOutputBuffer() {\n  this.buf = new DataBuffer();\n  DataOutputBuffer.super_.call(this, this.buf, this.constructor);\n}\nutil.inherits(DataOutputBuffer, DataOutputStream);\n\nDataOutputBuffer.prototype.getData = function () {\n  return Buffer.concat(this.buf.datas, this.buf.length);\n};\n\nDataOutputBuffer.prototype.getLength = function () {\n  return this.buf.length;\n};\n\nDataOutputBuffer.prototype.writeString = function (s) {\n  if (!s) {\n    return this.writeInt(-1);\n  }\n  if (typeof s === 'string') {\n    s = new Buffer(s, 'utf8');\n  }\n  this.writeInt(s.length);\n  return this.write(s);\n};\n\n\nmodule.exports = DataOutputBuffer;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/data_output_stream.js":"/*!\n * node-hbase-client - lib/data_output_stream.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar WritableUtils = require('./writable_utils');\nvar Long = require('long');\n\nfunction DataOutputStream(out) {\n  this.out = out;\n  this.written = 0;\n}\n\nDataOutputStream.prototype.incCount = function (size) {\n  this.written += size;\n};\n\nDataOutputStream.prototype.write = function (b, offset, length) {\n  length = length === undefined ? b.length : length;\n  if (offset !== undefined) {\n    b = b.slice(offset, offset + length);\n  }\n  \n  this.out.write(b);\n  this.incCount(length);\n};\n\n/**\n * Writes out a <code>byte</code> to the underlying output stream as \n * a 1-byte value. If no exception is thrown, the counter \n * <code>written</code> is incremented by <code>1</code>.\n *\n * @param      v   a <code>byte</code> value to be written.\n */\nDataOutputStream.prototype.writeByte = function (v) {\n  if (!Buffer.isBuffer(v)) {\n    v = new Buffer([v]);\n  }\n  this.write(v);\n};\n\n/**\n * Writes a <code>boolean</code> to the underlying output stream as \n * a 1-byte value. The value <code>true</code> is written out as the \n * value <code>(byte)1</code>; the value <code>false</code> is \n * written out as the value <code>(byte)0</code>. If no exception is \n * thrown, the counter <code>written</code> is incremented by \n * <code>1</code>.\n *\n * @param      v   a <code>boolean</code> value to be written.\n */\nDataOutputStream.prototype.writeBoolean = function (v) {\n  this.writeByte(v ? 1 : 0);\n};\n\n/**\n * Writes a <code>short</code> to the underlying output stream as two\n * bytes, high byte first. If no exception is thrown, the counter \n * <code>written</code> is incremented by <code>2</code>.\n *\n * @param      v   a <code>short</code> to be written.\n */\nDataOutputStream.prototype.writeShort = function (v) {\n  this.writeChar(v);\n};\n\n/**\n * Writes a <code>char</code> to the underlying output stream as a \n * 2-byte value, high byte first. If no exception is thrown, the \n * counter <code>written</code> is incremented by <code>2</code>.\n *\n * @param      v   a <code>char</code> value to be written.\n */\nDataOutputStream.prototype.writeChar = function (v) {\n  var buf = new Buffer(2);\n  buf.writeInt16BE(v, 0, true);\n  this.write(buf);\n};\n\n/**\n * Writes an <code>int</code> to the underlying output stream as four\n * bytes, high byte first. If no exception is thrown, the counter \n * <code>written</code> is incremented by <code>4</code>.\n *\n * @param      v   an <code>int</code> to be written.\n */\nDataOutputStream.prototype.writeInt = function (v) {\n  var buf = new Buffer(4);\n  buf.writeInt32BE(v, 0);\n  this.write(buf);\n};\n\nvar ZERO_LONG_BUFFER = new Buffer([0, 0, 0, 0, 0, 0, 0, 0]);\n\nvar MAX_INT32 = 4294967295;\nvar MIN_INT32 = -4294967296;\n// var MAX_NUMBER = 9007199254740992;\n\n/**\n * Writes a <code>long</code> to the underlying output stream as eight\n * bytes, high byte first. In no exception is thrown, the counter \n * <code>written</code> is incremented by <code>8</code>.\n *\n * @param      v   a <code>long</code> to be written.\n */\nDataOutputStream.prototype.writeLong = function (v) {\n  // In Javascript, numbers are 64 bit floating point values. \n  // The largest integer (magnitude) is 253, or Math.pow(2,53), or 9007199254740992.\n  // Bitwise Operators: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n  // v should below MAX_INT32.\n  //\n  // 32位带符号整数表单范围是 -Math.pow(2,31) ~ Math.pow(2,31)-1 即 -2147483648～2147483647,\n  // 而 js 数字的精度是双精度，64位，如果一个超过 2147483647 的整数参与位运算的时候就需要注意，\n  // 其二进制溢出了,截取32位后，如果第32位是1将被解读为负数(补码)。\n  // \n  // 位移运算不能移动超过32位，如果试图移动超过31位，将位数 对32取模后再移位\n  \n  // java code\n  // writeBuffer[0] = v >>> 56;\n  // writeBuffer[1] = v >>> 48;\n  // writeBuffer[2] = v >>> 40;\n  // writeBuffer[3] = v >>> 32;\n  // writeBuffer[4] = v >>> 24;\n  // writeBuffer[5] = v >>> 16;\n  // writeBuffer[6] = v >>>  8;\n  // writeBuffer[7] = v >>>  0;\n\n  if (v === 0) {\n    this.write(ZERO_LONG_BUFFER);\n    return;\n  }\n  \n  this.write(WritableUtils.toLongBytes(v));\n};\n\nDataOutputStream.prototype.writeBytes = function (bytes) {\n  this.write(bytes);\n};\n\n/**\n * Writes a string to the specified DataOutput using\n * <a href=\"DataInput.html#modified-utf-8\">modified UTF-8</a>\n * encoding in a machine-independent manner. \n * <p>\n * First, two bytes are written to out as if by the <code>writeShort</code>\n * method giving the number of bytes to follow. This value is the number of\n * bytes actually written out, not the length of the string. Following the\n * length, each character of the string is output, in sequence, using the\n * modified UTF-8 encoding for the character. If no exception is thrown, the\n * counter <code>written</code> is incremented by the total number of \n * bytes written to the output stream. This will be at least two \n * plus the length of <code>str</code>, and at most two plus \n * thrice the length of <code>str</code>.\n *\n * @param      str   a string to be written.\n * @return     The number of bytes written out.\n */\nDataOutputStream.prototype.writeUTF = function (str) {\n  var buf = new Buffer(str);\n  var data = new Buffer(buf.length + 2);\n  data.writeInt16BE(buf.length, 0);\n  buf.copy(data, 2);\n  this.write(data);\n};\n\n\nmodule.exports = DataOutputStream;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/data_input_buffer.js":"/*jslint bitwise: true */\n/*!\n * node-hbase-client - lib/data_input_buffer.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar util = require('util');\nvar DataInputStream = require('./data_input_stream');\nvar NegativeArraySizeException = require('./errors').NegativeArraySizeException;\n\nfunction InputBuffer(buf) {\n  this.buf = buf;\n  this.offset = 0;\n}\n\nInputBuffer.prototype.read = function (size) {\n  var offset = this.offset;\n  var end = offset + size;\n  this.offset = end;\n  return this.buf.slice(offset, end);\n};\n\nfunction DataInputBuffer(buf) {\n  this.in = new InputBuffer(buf);\n}\nutil.inherits(DataInputBuffer, DataInputStream);\n\n/*\n * Read a String as a Network Int n, followed by n Bytes\n * Alternative to 16 bit read/writeUTF.\n * Encoding standard is... ?\n */\nDataInputBuffer.prototype.readString = function () {\n  var length = this.readInt();\n  if (length === -1) {\n    return null;\n  }\n  \n  return this.read(length).toString('utf8');\n};\n\n/** Read a UTF8 encoded string from in equal to Text.readString()\n */\nDataInputBuffer.prototype.readVString = function () {\n  var length = this.readVInt();\n  return this.read(length).toString('utf8');\n};\n\n/**\n * Given the first byte of a vint/vlong, determine the sign\n * \n * @param value the first byte\n * @return is the value negative\n */\nDataInputBuffer.isNegativeVInt = function (value) {\n  return value < -120 || (value >= -112 && value < 0);\n};\n\n/**\n * Parse the first byte of a vint/vlong to determine the number of bytes\n * \n * @param value the first byte of the vint/vlong\n * @return the total number of bytes (1 to 9)\n */\nDataInputBuffer.decodeVIntSize = function (value) {\n  if (value >= -112) {\n    return 1;\n  } else if (value < -120) {\n    return -119 - value;\n  }\n  return -111 - value;\n};\n\n/**\n * Reads a zero-compressed encoded long from input stream and returns it.\n * \n * @return deserialized long from stream.\n */\nDataInputBuffer.prototype.readVLong = function () {\n  // TODO: support Long\n  var firstByte = this.readByte();\n  var len = DataInputBuffer.decodeVIntSize(firstByte);\n  if (len === 1) {\n    return firstByte;\n  }\n  var size = len - 1;\n  var buf = this.read(size);\n  var i = 0;\n  for (var idx = 0; idx < size; idx++) {\n    var b = buf[idx];\n    i = i << 8;\n    i = i | (b & 0xFF);\n  }\n  return DataInputBuffer.isNegativeVInt(firstByte) ? (i ^ -1) : i;\n};\n\n/**\n * Reads a zero-compressed encoded integer from input stream and returns it.\n * \n * @return deserialized integer from stream.\n */\nDataInputBuffer.prototype.readVInt = function () {\n  return this.readVLong();\n};\n\n/**\n * Read byte-array written with a WritableableUtils.vint prefix.\n * \n * @return byte array read off `this.in`.\n */\nDataInputBuffer.prototype.readByteArray = function () {\n  var len = this.readVInt();\n  return this.in.read(len);\n};\n\n\nmodule.exports = DataInputBuffer;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/data_input_stream.js":"/*!\n * node-hbase-client - lib/data_input_stream.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('hbase:data_input_stream');\nvar Readable = require('readable-stream').Readable;\nvar Bytes = require('./util/bytes');\nvar WritableUtils = require('./writable_utils');\n\nfunction DataInputStream(io) {\n  this.in = io;\n  if (typeof io.read !== 'function') {\n    this.in = new Readable();\n    this.in.wrap(io);\n  }\n  this.bytearr = new Buffer(80);\n}\n\nDataInputStream.prototype.read = function (b, callback) {\n  return this.in.read(b, 0, b.length);\n};\n\nDataInputStream.prototype.readBytes = function (size, callback) {\n  var buf = this.in.read(size);\n  debug('readBytes: %d size, Got %s, socket total read bytes: %d', size, buf ? 'Buffer' : null, this.in.bytesRead);\n  if (buf === null) {\n    return this.in.once('readable', this.readBytes.bind(this, size, callback));\n  }\n  callback(null, buf);\n};\n\nDataInputStream.prototype.readFields = function (fields, callback, startIndex, data) {\n  var self = this;\n  var lastError = null;\n  data = data || {};\n  var next = function (index) {\n    if (index === fields.length) {\n      return callback(lastError, data);\n    }\n    var field = fields[index];\n    var nextIndex = index + 1;\n\n    var value = self[field.method]();\n    debug('readFields: %s index %d, name: %s, got %s, data %j, socket total read bytes: %d', \n      field.method, index, field.name, value, data, self.in.bytesRead);\n    if (value === null) {\n      // TODO: listeners too much\n      return self.in.once('readable', self.readFields.bind(self, fields, callback, index, data));\n    }\n    data[field.name] = value;\n    next(nextIndex);\n  };\n  startIndex = startIndex || 0;\n  next(startIndex);\n};\n\n/**\n * See the general contract of the <code>readFully</code>\n * method of <code>DataInput</code>.\n * <p>\n * Bytes\n * for this operation are read from the contained\n * input stream.\n *\n * @param      len   the number of bytes to read.\n */\nDataInputStream.prototype.readFully = function (len, callback) {\n  var buf = this.in.read(len);\n  if (buf === null) {\n    return this.in.once('readable', this.readFully.bind(this, len, callback));\n  }\n  callback(null, buf);\n};\n\n/**\n * See the general contract of the <code>readBoolean</code>\n * method of <code>DataInput</code>.\n * <p>\n * Bytes for this operation are read from the contained\n * input stream.\n *\n * @return     the <code>boolean</code> value read.\n */\nDataInputStream.prototype.readBoolean = function () {\n  var buf = this.in.read(1);\n  return buf ? buf[0] !== 0 : null;\n};\n\n/**\n * See the general contract of the <code>readByte</code>\n * method of <code>DataInput</code>.\n * <p>\n * Bytes\n * for this operation are read from the contained\n * input stream.\n *\n * @return     the next byte of this input stream as a signed 8-bit\n *             <code>byte</code>.\n */\nDataInputStream.prototype.readByte = function () {\n  var buf = this.in.read(1);\n  return buf ? buf.readInt8(0) : null;\n};\n\n/**\n * See the general contract of the <code>readInt</code>\n * method of <code>DataInput</code>.\n * <p>\n * Bytes\n * for this operation are read from the contained\n * input stream.\n *\n * @return     the next four bytes of this input stream, interpreted as an\n *             <code>int</code>.\n */\nDataInputStream.prototype.readInt = function () {\n  var buf = this.in.read(4);\n  return buf ? buf.readInt32BE(0) : null;\n};\n\n/**\n * See the general contract of the <code>readLong</code>\n * method of <code>DataInput</code>.\n * <p>\n * Bytes\n * for this operation are read from the contained\n * input stream.\n *\n * @return     the next eight bytes of this input stream, interpreted as a\n *             <code>long</code>.\n */\nDataInputStream.prototype.readLong = function () {\n  var buf = this.in.read(8);\n  if (buf === null) {\n    return buf;\n  }\n  return WritableUtils.toLong(buf);\n};\n\n\nmodule.exports = DataInputStream;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/connection.js":"/*!\n * node-hbase-client - lib/connection.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('hbase:connection');\nvar Long = require('long');\nvar Readable = require('readable-stream').Readable;\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar utility = require('utility');\nvar net = require('net');\nvar Text = require('./text');\nvar Bytes = require('./util/bytes');\nvar ResponseFlag = require('./ipc/response_flag');\nvar DataInputBuffer = require('./data_input_buffer');\nvar DataOutputBuffer = require('./data_output_buffer');\nvar DataInputStream = require('./data_input_stream');\nvar DataOutputStream = require('./data_output_stream');\nvar HbaseObjectWritable = require('./io/hbase_object_writable');\nvar Invocation = require('./ipc/invocation');\nvar HConstants = require('./hconstants');\nvar errors = require('./errors');\nvar RemoteException = errors.RemoteException;\n\nvar HEADER = new Buffer(\"hrpc\", \"utf8\");\nvar CURRENT_VERSION = 3;\nvar PING_CALL_ID = new Buffer(4);\nPING_CALL_ID.writeInt32BE(-1, 0);\n\n/**\n * The IPC connection header sent by the client to the server\n * on connection establishment.\n *\n * Create a new {@link ConnectionHeader} with the given <code>protocol</code>\n * and {@link User}.\n * @param protocol protocol used for communication between the IPC client\n *                 and the server\n * @param user {@link User} of the client communicating with\n *            the server\n */\nfunction ConnectionHeader(protocol, user) {\n  this.protocol = protocol;\n  this.user = user;\n}\n\nConnectionHeader.prototype.write = function (out) {\n  Text.writeString(out, this.protocol || '');\n},\n\nConnectionHeader.prototype.getProtocol = function () {\n  return this.protocol;\n};\n\nConnectionHeader.prototype.getUser = function () {\n  return null;\n};\n\nConnectionHeader.prototype.toString = function () {\n  return this.protocol;\n};\n\nvar _Connection_id = 0;\n\n/** Thread that reads responses and notifies callers.  Each connection owns a\n * socket connected to a remote address.  Calls are multiplexed through this\n * socket: responses may be delivered out of order. */\nfunction Connection(options) {\n  EventEmitter.call(this);\n  this.id = _Connection_id++;\n  this.header = null; // connection header\n  this.socket = null; // connected socket\n  this.in;\n  this.out;\n\n  this.tcpNoDelay = false; // nodelay not or\n  this.tcpKeepAlive = true;\n\n  // currently active calls\n  this.calls = {};\n\n  this.address = {host: options.host, port: options.port};\n  this.hostnamePort = options.host + ':' + options.port;\n  this.name = 'Connection(' + this.hostnamePort + ')#' + this.id;\n  var protocol = options.protocol || HConstants.PROTOCOL;\n  this.rpcTimeout = options.rpcTimeout || HConstants.DEFAULT_HBASE_RPC_TIMEOUT;\n  this.pingInterval = options.pingInterval || HConstants.DEFAULT_PING_INTERVAL;\n\n  this.logger = options.logger || console;\n  this.header = new ConnectionHeader(protocol, options.ticket);\n  this._connected = false;\n  this._socketError = null;\n  this.setupIOstreams();\n  this._callNums = 0;\n}\n\nutil.inherits(Connection, EventEmitter);\n\nConnection.prototype.setupConnection = function () {\n  var ioFailures = 0;\n  var timeoutFailures = 0;\n  this.socket = net.connect(this.address);\n  this.socketReadable = this.socket;\n  if (typeof this.socketReadable.read !== 'function') {\n    this.socketReadable = new Readable();\n    this.socketReadable.wrap(this.socket);\n    // ignore error event\n    this.socketReadable.on('error', utility.noop);\n  }\n  this.socket.setNoDelay(this.tcpNoDelay);\n  this.socket.setKeepAlive(this.tcpKeepAlive);\n  // if (this.remoteId.rpcTimeout > 0) {\n  //   this.pingInterval = this.remoteId.rpcTimeout;\n  // }\n  // this.socket.setTimeout(this.pingInterval);\n  this.socket.on('timeout', this._handleTimeout.bind(this));\n  this.socket.on('close', this._handleClose.bind(this));\n\n  // when error, response all calls error\n  this.socket.on('error', this._handleError.bind(this));\n\n  // send ping\n  this._pingTimer = setInterval(this.sendPing.bind(this), this.pingInterval);\n};\n\nConnection.prototype._cleanupCalls = function (err) {\n  var count = 0;\n  var calls = this.calls;\n  // should reset calls before traverse it.\n  this.calls = {};\n  for (var id in calls) {\n    var call = calls[id];\n    call.setException(err);\n    count++;\n  }\n  this.logger.warn('%s: cleanup %d calls, send \"%s:%s\" response.', this.name, count, err.name, err.message);\n  // clean timer\n  if (this._pingTimer) {\n    clearInterval(this._pingTimer);\n    this._pingTimer = null;\n  }\n};\n\nConnection.prototype._handleTimeout = function () {\n  this._close(new errors.ConnectionClosedException(this.name + ' socket close by \"timeout\" event.'));\n};\n\nConnection.prototype._handleClose = function () {\n  debug('%s `close` event emit', this.name);\n  this.closed = true;\n  // tell user not use this connection first\n  this.emit('close'); // let client close first.\n\n  var err = this._closeError || this._socketError;\n  if (!err) {\n    err = new errors.ConnectionClosedException(this.name + ' closed with no error.');\n    this.logger.warn(err.message);\n  }\n  this._cleanupCalls(err);\n};\n\nConnection.prototype._handleError = function (err) {\n  debug('%s `error` event emit: %s', this.name, err);\n  if (err.message.indexOf('ECONNREFUSED') >= 0) {\n    err.name = 'ConnectionRefusedException';\n  }\n  if (err.message.indexOf('ECONNRESET') >= 0 || err.message.indexOf('This socket is closed') >= 0) {\n    err.name = 'ConnectionClosedException';\n  }\n  this._socketError = err;\n  if (!this._connected) {\n    this.emit('connectError', err);\n  }\n  this._cleanupCalls(err);\n};\n\n/** Connect to the server and set up the I/O streams. It then sends\n * a header to the server and starts\n * the connection thread that waits for responses.\n * @throws java.io.IOException e\n */\nConnection.prototype.setupIOstreams = function () {\n  var self = this;\n  debug('Connecting to %s', self.name);\n  self.setupConnection();\n  self.in = new DataInputStream(self.socketReadable);\n  self.out = new DataOutputStream(self.socket);\n\n  self.socket.on('connect', function () {\n    this._connected = true;\n    self.writeHeader();\n    self._nextResponse();\n    self.emit('connect');\n    debug('Connected to %s', self.name);\n  });\n};\n\n/* Write the header for each connection\n * Out is not synchronized because only the first thread does this.\n */\nConnection.prototype.writeHeader = function () {\n  this.out.write(HEADER);\n  this.out.writeByte(CURRENT_VERSION);\n  //When there are more fields we can have ConnectionHeader Writable.\n  var buf = new DataOutputBuffer();\n  this.header.write(buf);\n\n  var bufLen = buf.getLength();\n  this.out.writeInt(bufLen);\n  this.out.write(buf.getData());\n};\n\nvar _pingCount = 0;\nConnection.prototype.sendPing = function () {\n  debug('%s sendPing #%d', this.name, _pingCount++);\n  this.out.write(PING_CALL_ID);\n};\n\n/* Initiates a call by sending the parameter to the remote server.\n * Note: this is not called from the Connection thread, but by other\n * threads.\n */\nConnection.prototype.sendParam = function (call) {\n  // For serializing the data to be written.\n\n  //this.logger.info('%s sending #%s', this.name, call.id);\n\n  var d = new DataOutputBuffer();\n  d.writeInt(0); // placeholder for data length\n  d.writeInt(call.id);\n  call.param.write(d);\n  var data = d.getData();\n  var dataLength = d.getLength();\n\n  // fill in the placeholder\n  Bytes.putInt(data, 0, dataLength - 4);\n  this.out.write(data, 0, dataLength);\n};\n\nConnection.prototype._close = function (err) {\n  this.closed = true;\n  this._closeError = err;\n  // TODO: end or close?\n  // this.socket.end();\n  this.logger.warn('%s socket destroy().', this.name);\n  this.socket.destroy();\n};\n\nConnection.prototype.close = Connection.prototype._close;\n\n// ignore errors, no need to close the current connection\nvar IGNORE_EXCEPTIONS = {\n  'org.apache.hadoop.hbase.regionserver.NoSuchColumnFamilyException': true,\n  'org.apache.hadoop.hbase.regionserver.WrongRegionException': true,\n  'org.apache.hadoop.hbase.NotServingRegionException': true,\n};\n\nConnection.prototype._nextResponse = function () {\n  var self = this;\n  // See HBaseServer.Call.setResponse for where we write out the response.\n  // It writes the call.id (int), a flag byte, then optionally the length\n  // of the response (int) followed by data.\n  self.in.readFields([\n    {name: 'id', method: 'readInt'},\n    {name: 'flag', method: 'readByte'},\n    {name: 'size', method: 'readInt'},\n  ], function (err, data) {\n\n    if (!data.hasOwnProperty('id') || !data.hasOwnProperty('flag') || !data.hasOwnProperty('size')) {\n      self.logger.warn('[ERROR] [%s] data format wrong: %j, keys: %j', Date(), data, Object.keys(data));\n      var msg = 'data packet wrong, data: ' + JSON.stringify(data);\n      debug('%s: %s', self.name, msg);\n      err = new RemoteException('RemoteException', msg);\n      self._close(err);\n      return;\n    }\n\n    // Read the call id.\n    var id = data && data.id;\n    var size = data.size - 9; // remove header size, Int, Byte, Int, 9 bytes\n    var flag = data.flag;\n    var isError = ResponseFlag.isError(flag);\n    debug('receiveResponse: got %s:call#%s response, flag: %s, isError: %s, size: %s',\n      self.name, id, flag, isError, size);\n\n    var call = self.calls[id];\n\n    if (!call) {\n      // call timeout event will cause connection remove the call\n      debug('[WARNNING] [%s] %s:call#%s not exists, data: %j', Date(), id, data);\n    } else {\n      delete self.calls[id];\n    }\n\n    if (err) {\n      call && call.setException(err);\n      self._close();\n      return;\n    }\n\n    if (typeof flag !== 'number' || !ResponseFlag.isLength(flag)) {\n      debug('%s:call#%s missing data length packet, flag: %s', self.name, id, flag);\n      err = new RemoteException('RemoteException', 'missing data length packet, flag: ' + flag);\n      call && call.setException(err);\n      self._close();\n      return;\n    }\n\n    self.in.readBytes(size, function (err, buf) {\n      var io = new DataInputBuffer(buf);\n\n      var state = io.readInt(); // Read the state.  Currently unused.\n      if (isError) {\n        err = new RemoteException(io.readString(), io.readString());\n        call && call.setException(err);\n        if (!IGNORE_EXCEPTIONS[err.name]) {\n          self._close(err);\n        }\n      } else {\n        var obj = HbaseObjectWritable.readFields(io);\n        debug('call#%s got %s instance', id, obj.declaredClass);\n        call && call.setValue(obj.instance);\n      }\n\n      // RangeError: Maximum call stack size exceeded\n      // self._nextResponse();\n      process.nextTick(self._nextResponse.bind(self));\n    });\n  });\n\n};\n\n// impl HRegionInterface\nConnection.prototype.call = function (method, parameters, rpcTimeout, callback) {\n  if (typeof rpcTimeout === 'function') {\n    callback = rpcTimeout;\n    rpcTimeout = null;\n  }\n  rpcTimeout = rpcTimeout || this.rpcTimeout;\n  var param = new Invocation(method, parameters);\n  var call = new Call(param, rpcTimeout);\n  var self = this;\n  var connectionCallId = self._callNums++;\n  self.calls[call.id] = call;\n  call.on('done', function (err, value) {\n    if (err) {\n      err.connection = self.name;\n      if (err.message.indexOf(err.connection) < 0) {\n        err.message += ' (' + err.connection + ', ' + connectionCallId + ':' + self._callNums + ')';\n      }\n    }\n    callback(err, value);\n  }); // TODO: handle MAX Number error response, should close the connection.\n\n  if (self.closed) {\n    return this._handleClose();\n  }\n\n  call.on('timeout', function () {\n    // remove the call\n    delete self.calls[call.id];\n  });\n  debug('%s: sent call#%s request data', self.name, call.id);\n  this.sendParam(call);\n};\n\n/**\n * Return all the data for the row that matches <i>row</i> exactly,\n * or the one that immediately preceeds it.\n *\n * @param regionName region name\n * @param row row key\n * @param family Column family to look for row in.\n * @return map of values\n * @throws IOException e\n */\nConnection.prototype.getClosestRowBefore = function (regionName, row, family, rpcTimeout, callback) {\n  this.call('getClosestRowBefore', [regionName, row, family], rpcTimeout, callback);\n};\n\n/**\n * Return protocol version corresponding to protocol interface.\n *\n * @param protocol The classname of the protocol interface\n * @param clientVersion The version of the protocol that the client speaks\n * @return the version that the server will speak\n * @throws IOException if any IO error occurs\n */\nConnection.prototype.getProtocolVersion = function (protocol, clientVersion, rpcTimeout, callback) {\n  protocol = protocol || HConstants.PROTOCOL;\n  clientVersion = clientVersion || HConstants.CLIENT_VERSION;\n  if (!(clientVersion instanceof Long)) {\n    clientVersion = Long.fromNumber(clientVersion);\n  }\n  this.call('getProtocolVersion', [protocol, clientVersion], rpcTimeout, callback);\n};\n\n/**\n * Perform Get operation.\n * @param regionName name of region to get from\n * @param get Get operation\n * @return Result\n * @throws IOException e\n */\nConnection.prototype.get = function (regionName, get, callback) {\n  this.call('get', [regionName, get], callback);\n};\n\n/**\n * Put data into the specified region if check passes\n * @param regionName region name\n * @param wrapped args\n * @throws IOException e\n */\nConnection.prototype.checkAndPut = function (regionName, o, callback) {\n  var a = [regionName, o.getRow(), o.getFamily(), o.getQualifier(), o.getValue(), o.getPut()];\n  this.call('checkAndPut', a, callback);\n};\n\n/**\n * Put data into the specified region\n * @param regionName region name\n * @param put the data to be put\n * @throws IOException e\n */\nConnection.prototype.put = function (regionName, put, callback) {\n  this.call('put', [regionName, put], callback);\n};\n\n/**\n * Delete data from the specified region\n * @param regionName region name\n * @param put the data to be put\n * @throws IOException e\n */\nConnection.prototype.delete = function (regionName, del, callback) {\n  this.call('delete', [regionName, del], callback);\n};\n\n/**\n * Method used for doing multiple actions(Deletes, Gets and Puts) in one call\n * @param {MultiAction} multi\n * @return MultiResult\n * @throws IOException\n */\nConnection.prototype.multi = function (multi, callback) {\n  this.call('multi', [multi], callback);\n};\n\n/**\n * Opens a remote scanner with a RowFilter.\n *\n * @param regionName name of region to scan\n * @param scan configured scan object\n * @return scannerId scanner identifier used in other calls\n * @throws IOException e\n */\nConnection.prototype.openScanner = function (regionName, scan, callback) {\n  this.call('openScanner', [regionName, scan], callback);\n};\n\n/**\n * Get the next set of values\n *\n * @param scannerId clientId passed to openScanner\n * @return map of values; returns null if no results.\n * @throws IOException e\n */\n// Connection.prototype.next = function (scannerId, callback) {\n//   this.call('next', [scannerId], callback);\n// };\n\n/**\n * Get the next set of values\n *\n * @param scannerId clientId passed to openScanner\n * @param [numberOfRows] the number of rows to fetch\n * @return Array of Results (map of values); array is empty if done with this\n * region and null if we are NOT to go to the next region (happens when a\n * filter rules that the scan is done).\n * @throws IOException e\n */\nConnection.prototype.nextResult = function (scannerId, numberOfRows, callback) {\n  if (typeof numberOfRows === 'function') {\n    callback = numberOfRows;\n    numberOfRows = null;\n  }\n  var params = [scannerId];\n  if (numberOfRows) {\n    params.push(numberOfRows);\n  }\n  this.call('next', params, callback);\n};\n\n/**\n * Close a scanner\n *\n * @param scannerId the scanner id returned by openScanner\n * @throws IOException e\n */\nConnection.prototype.closeScanner = function (scannerId, callback) {\n  this.call('close', [scannerId], callback);\n};\n\nConnection.Call_Counter = 0;\n\n\n/** A call waiting for a value. */\nfunction Call(param, timeout) {\n  EventEmitter.call(this);\n  this.id = Connection.Call_Counter++; // call id\n  this.param = param; // parameter\n  this.value = null; // value, null if error\n  this.error = null; // exception, null if value\n  this.done = false; // true when call is done\n  this.startTime = Date.now();\n\n  this.timeout = timeout;\n  if (timeout && timeout > 0) {\n    this.timer = setTimeout(this._handleTimeout.bind(this), timeout);\n  }\n}\n\nutil.inherits(Call, EventEmitter);\n\nCall.prototype._handleTimeout = function () {\n  var err = new errors.RemoteCallTimeoutException(this.timeout + ' ms timeout (call#' + this.id + ')');\n  this.setException(err);\n  this.emit('timeout');\n};\n\n/** Indicate when the call is complete and the\n * value or error are available.  Notifies by default.  */\nCall.prototype.callComplete = function () {\n  if (this.timer) {\n    clearTimeout(this.timer);\n    this.timer = null;\n  }\n  if (this.done) {\n    // if done before, do not emit done again\n    return;\n  }\n  this.done = true;\n  if (debug.enabled) {\n    debug('call#%d use %d ms', this.id, Date.now() - this.startTime);\n  }\n  this.emit('done', this.error, this.value);\n};\n\n/** Set the exception when there is an error.\n * Notify the caller the call is done.\n *\n * @param error exception thrown by the call; either local or remote\n */\nCall.prototype.setException = function (err) {\n  debug('call#%s error: %s', this.id, err.message);\n  this.error = err;\n  this.callComplete();\n};\n\n/** Set the return value when there is no error.\n * Notify the caller the call is done.\n *\n * @param value return value of the call.\n */\nCall.prototype.setValue = function (value) {\n  this.value = value;\n  this.callComplete();\n};\n\nCall.prototype.getStartTime = function () {\n  return this.startTime;\n};\n\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/ipc/response_flag.js":"/*jslint bitwise: true */\n/*!\n * node-hbase-client - lib/ipc/resposer_flag.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\n/**\n * Utility for managing the flag byte passed in response to a\n * {@link HBaseServer.Call}\n */\nvar ERROR_BIT = 0x1;\nvar LENGTH_BIT = 0x2;\n\nexports.isError = function (flag) {\n  return (flag & ERROR_BIT) !== 0;\n};\n\nexports.isLength = function (flag) {\n  return (flag & LENGTH_BIT) !== 0;\n};\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/ipc/invocation.js":"/*!\n * node-hbase-client - lib/ipc/invocation.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('hbase:ipc:invocation');\nvar util = require('util');\nvar VersionedWritable = require('../io/version_writable');\nvar HbaseObjectWritable = require('../io/hbase_object_writable');\nvar HConstants = require('../hconstants');\n\nvar RPC_VERSION = 1;\n\n/** A method invocation, including the method name and its parameters.*/\nfunction Invocation(method, parameters) {\n  Invocation.super_.call(this);\n  // method: {name, parameterTypes, parameters}\n  // name: 'get', parameterTypes: ['Buffer', 'Get.class'], parameters: [buf, get]\n  // public Invocation(Method method, Object[] parameters) {\n  this.methodName = method;\n  this.parameterClasses = [];\n  this.parameters = parameters;\n  for (var i = 0; i < parameters.length; i++) {\n    this.parameterClasses.push(parameters[i].constructor);\n  }\n  this.clientVersion = HConstants.CLIENT_VERSION; // HRegionInterface: public static final long VERSION = 29L;\n  this.clientMethodsHash = 0;\n  if (method === 'getProtocolVersion') {\n    this.clientVersion = 0;\n    this.clientMethodsHash = 0;\n  }\n}\n\nutil.inherits(Invocation, VersionedWritable);\n\nInvocation.prototype.write = function (out) {\n  Invocation.super_.prototype.write.call(this, out);\n  out.writeUTF(this.methodName);\n  out.writeLong(this.clientVersion);\n  out.writeInt(this.clientMethodsHash);\n  out.writeInt(this.parameters.length);\n  debug('writable: method: %s, clientVersion: %s, clientMethodsHash: %s, parameters len: %d', \n    this.methodName, this.clientVersion, this.clientMethodsHash, this.parameters.length);\n  for (var i = 0; i < this.parameters.length; i++) {\n    HbaseObjectWritable.writeObject(out, this.parameters[i], this.parameterClasses[i]);\n  }\n};\n\nInvocation.prototype.getVersion = function () {\n  return RPC_VERSION;\n};\n\n\nmodule.exports = Invocation;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/io/version_writable.js":"/*!\n * node-hbase-client - lib/io/version_writable.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar VersionMismatchException = require('../errors').VersionMismatchException;\n\nfunction VersionedWritable() {}\n\nVersionedWritable.prototype.write = function (out) {\n  out.writeByte(this.getVersion()); // store version\n};\n\n// VersionedWritable.prototype.readFields = function (io) {\n//   var version = io.readByte(); // read version\n//   if (version !== this.getVersion()) {\n//     throw new VersionMismatchException(this.getVersion(), version);\n//   }\n// };\n\n\nmodule.exports = VersionedWritable;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/delete.js":"/*!\n * node-hbase-client - lib/delete.js\n * Copyright(c) 2013 tangyao<tangyao@alibaba-inc.com>\n * MIT Licensed\n */\n\n'use strict';\n\nvar util = require('util');\nvar errors = require('./errors');\nvar KeyValue = require('./keyvalue');\nvar Bytes = require('./util/bytes');\nvar OperationWithAttributes = require('./operation_with_attributes');\nvar HConstants = require('./hconstants');\n\nvar DELETE_VERSION = 3;\n\n/**\n * Create a Delete operation for the specified row and timestamp, using\n * an optional row lock.<p>\n *\n * If no further operations are done, this will delete all columns in all\n * families of the specified row with a timestamp less than or equal to the\n * specified timestamp.<p>\n *\n * This timestamp is ONLY used for a delete row operation.  If specifying\n * families or columns, you must specify each timestamp individually.\n * @param {byte []} row row key\n * @param {long} timestamp maximum version timestamp (only for delete row)\n * @param {RowLock} rowLock previously acquired row lock, or null\n */\nfunction Delete(row, timestamp, rowLock) {\n  OperationWithAttributes.call(this);\n  if (row && !Buffer.isBuffer(row)) {\n    row = Bytes.toBytes(row);\n  }\n  if (row === null || row.length > HConstants.MAX_ROW_LENGTH) {\n    throw new errors.IllegalArgumentException(\"Row key is invalid\");\n  }\n  this.row = row;\n  this.ts = timestamp || HConstants.LATEST_TIMESTAMP;\n  this.lockId = -1;\n  if (rowLock !== null && typeof rowLock !== 'undefined') {\n    this.lockId = rowLock.getLockId();\n  }\n  this.familyMap = {};\n  this.writeToWAL = true;\n}\n\nutil.inherits(Delete, OperationWithAttributes);\n\nDelete.prototype.getRow = function () {\n  return this.row;\n};\n\n/**\n * Set the timestamp of the delete.\n *\n * @param {long} timestamp\n */\nDelete.prototype.setTimestamp = function (timestamp) {\n  this.ts = timestamp;\n};\n\n/**\n * Delete all versions of the specified column with a timestamp less than\n * or equal to the specified timestamp.\n * @param {byte []} family family name\n * @param {byte []} qualifier column qualifier\n * @param {long} timestamp maximum version timestamp\n * @return this for invocation chaining\n */\nDelete.prototype.deleteColumns = function (family, qualifier, timestamp) {\n  if (family !== null && !Buffer.isBuffer(family)) {\n    family = Bytes.toBytes(family);\n  }\n  if (qualifier !== null && !Buffer.isBuffer(qualifier)) {\n    qualifier = Bytes.toBytes(qualifier);\n  }\n  timestamp = timestamp || HConstants.LATEST_TIMESTAMP;\n  var list = this.familyMap[family];\n  if (!list) {\n    list = this.familyMap[family] = [];\n  }\n  list.push(KeyValue.createKeyValue(this.row, family, qualifier, timestamp, KeyValue.Type.DeleteColumn));\n  return this;\n};\n\n/**\n * Delete the latest version of the specified column.\n * This is an expensive call in that on the server-side, it first does a\n * get to find the latest versions timestamp.  Then it adds a delete using\n * the fetched cells timestamp.\n * @param {byte []} family family name\n * @param {byte []} qualifier column qualifier\n * @param {long} timestamp version timestamp\n * @return this for invocation chaining\n */\nDelete.prototype.deleteColumn = function (family, qualifier, timestamp) {\n  if (family !== null && !Buffer.isBuffer(family)) {\n    family = Bytes.toBytes(family);\n  }\n  if (qualifier !== null && !Buffer.isBuffer(qualifier)) {\n    qualifier = Bytes.toBytes(qualifier);\n  }\n  timestamp = timestamp || HConstants.LATEST_TIMESTAMP;\n  var list = this.familyMap[family];\n  if(!list) {\n    list = this.familyMap[family] = [];\n  }\n  list.push(KeyValue.createKeyValue(this.row, family, qualifier, timestamp, KeyValue.Type.Delete));\n  return this;\n};\n\n/**\n * Delete all columns of the specified family with a timestamp less than\n * or equal to the specified timestamp.\n * <p>\n * Overrides previous calls to deleteColumn and deleteColumns for the\n * specified family.\n * @param {byte []} family family name\n * @param {long} timestamp maximum version timestamp\n * @return this for invocation chaining\n */\nDelete.prototype.deleteFamily = function (family, timestamp) {\n  if (family !== null && !Buffer.isBuffer(family)) {\n    family = Bytes.toBytes(family);\n  }\n  timestamp = timestamp || HConstants.LATEST_TIMESTAMP;\n  var list = this.familyMap[family] = [];\n  list.push(KeyValue.createKeyValue(this.row, family, null, timestamp, KeyValue.Type.DeleteFamily));\n  return this;\n};\n\n/**\n * Advanced use only.\n * Add an existing delete marker to this Delete object.\n * @param {KeyValue} kv An existing KeyValue of type \"delete\".\n * @return this for invocation chaining\n * @throws IOException\n */\nDelete.prototype.addDeleteMarker = function (kv) {\n  // TODO:\n};\n\nDelete.prototype.write = function (out) {\n  out.writeByte(DELETE_VERSION);\n  Bytes.writeByteArray(out, this.row);\n  out.writeLong(this.ts);\n  out.writeLong(this.lockId);\n  out.writeBoolean(this.writeToWAL);\n  out.writeInt(Object.keys(this.familyMap).length);\n  for (var family in this.familyMap) {\n    Bytes.writeByteArray(out, Bytes.toBytes(family));\n    var keys = this.familyMap[family];\n    out.writeInt(keys.length);\n    for (var j = 0; j < keys.length; j++) {\n      var kv = keys[j];\n      kv.write(out);\n    }\n  }\n  this.writeAttributes(out);\n};\n\nmodule.exports = Delete;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/scanner.js":"/*!\n * node-hbase-client - lib/scanner.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nfunction Scanner(server, id) {\n  EventEmitter.call(this);\n  \n  this.server = server;\n  this.id = id;\n}\n\nutil.inherits(Scanner, EventEmitter);\n\nScanner.prototype.next = function (numberOfRows, callback) {\n  this.server.nextResult(this.id, numberOfRows, callback);\n};\n\nScanner.prototype.close = function (callback) {\n  this.server.closeScanner(this.id, callback);\n};\n\n\nmodule.exports = Scanner;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/multi_response.js":"/*!\n * node-hbase-client - lib/multi_response.js\n * Copyright(c) 2013 tangyao<tangyao@alibaba-inc.com>\n * MIT Licensed\n */\n\n'use strict';\n\nvar util = require('util');\nvar errors = require('./errors');\nvar KeyValue = require('./keyvalue');\nvar Bytes = require('./util/bytes');\nvar OperationWithAttributes = require('./operation_with_attributes');\nvar HConstants = require('./hconstants');\nvar HbaseObjectWritable = require('./io/hbase_object_writable');\nvar Pair = require('./pair');\n\nfunction MultiResponse() {\n  if (!(this instanceof MultiResponse)) {\n    return new MultiResponse();\n  }\n  // map of regionName to list of (Results paired to the original index for that\n  // Result)\n  // Map<byte[], List<Pair<Integer, Object>>>\n  this.results = {};\n}\n\n/**\n * @return Number of pairs in this container\n */\nMultiResponse.prototype.size = function () {\n  var size = 0;\n  for (var key in this.results) {\n    var lst = this.results[key];\n    size += lst.length;\n  }\n  return size;\n};\n\n/**\n * @param  {DataInput} io\n */\nMultiResponse.prototype.readFields = function (io) {\n  this.results = {};\n  var mapSize = io.readInt();\n  for (var i = 0; i < mapSize; i++) {\n    var key = Bytes.toString(io.readByteArray());\n    var listSize = io.readInt();\n    var lst = [];\n    for (var j = 0; j < listSize; j++) {\n      var idx = io.readInt();\n      if (idx === -1) {\n        lst.push(null);\n      } else {\n        var isException = io.readBoolean();\n        var o = null;\n        if (isException) {\n          var klass = io.readString();\n          var desc = io.readString();\n          o = new Error(desc);\n          o.name = klass;\n        } else {\n          o = HbaseObjectWritable.readObject(io, null);\n        }\n        lst.push(new Pair(idx, o));\n      }\n    }\n    this.results[key] = lst;\n  }\n};\n\n\nHbaseObjectWritable.addToClass('MultiResponse.class', MultiResponse);\nmodule.exports = MultiResponse;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/pair.js":"/*!\n * node-hbase-client - lib/pair.js\n * Copyright(c) 2013 tangyao<tangyao@alibaba-inc.com>\n * MIT Licensed\n */\n\n'use strict';\n\nfunction Pair(a, b) {\n  this.first = a;\n  this.second = b;\n}\n\n/**\n * Return the first element stored in the pair.\n * @return T1\n */\nPair.prototype.getFirst = function () {\n  return this.first;\n};\n\n/**\n * Return the second element stored in the pair.\n * @return T2\n */\nPair.prototype.getSecond = function () {\n  return this.second;\n};\n\nPair.prototype.toString = function () {\n  return \"{\" + this.getFirst() + \",\" + this.getSecond() + \"}\";\n};\n\n\nmodule.exports = Pair;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/multi_action.js":"/*!\n * node-hbase-client - lib/multi_action.js\n * Copyright(c) 2013 tangyao<tangyao@alibaba-inc.com>\n * MIT Licensed\n */\n\n'use strict';\n\nvar util = require('util');\nvar errors = require('./errors');\nvar KeyValue = require('./keyvalue');\nvar Bytes = require('./util/bytes');\nvar OperationWithAttributes = require('./operation_with_attributes');\nvar HConstants = require('./hconstants');\nvar HbaseObjectWritable = require('./io/hbase_object_writable');\n\nfunction MultiAction() {\n  // map of regions to lists of puts/gets/deletes for that region.\n  // <byte[], List<Action<R>>>\n  this.actions = {};\n}\n\nMultiAction.prototype.size = function () {\n  var size = 0;\n  for (var key in this.actions) {\n    var list = this.actions[key];\n    size += list.length;\n  }\n  return size;\n};\n\n/**\n * Add an Action to this container based on it's regionName. If the regionName\n * is wrong, the initial execution will fail, but will be automatically\n * retried after looking up the correct region.\n *\n * @param {regionInfo} regionName\n * @param {Action<R>} action\n */\nMultiAction.prototype.add = function (regionInfo, action) {\n  var key = regionInfo.regionNameStr;\n  var rsActions = this.actions[key];\n  if (!rsActions) {\n    rsActions = this.actions[key] = {regionInfo: regionInfo, list: []};\n  }\n  rsActions.list.push(action);\n};\n\n/**\n * @return Set<byte[]>\n */\nMultiAction.prototype.getRegions = function () {\n  return Object.keys(this.actions);\n};\n\n/**\n * @param {DataOutput} out\n */\nMultiAction.prototype.write = function (out) {\n  out.writeInt(Object.keys(this.actions).length);\n  for (var key in this.actions) {\n    var obj = this.actions[key];\n    Bytes.writeByteArray(out, obj.regionInfo.getRegionName());\n    var lst = obj.list;\n    out.writeInt(lst.length);\n    for (var i = 0; i < lst.length; i++) {\n      var action = lst[i];\n      HbaseObjectWritable.writeObject(out, action); // TODO:\n    }\n  }\n};\n\n\nmodule.exports = MultiAction;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/action.js":"/*!\n * node-hbase-client - lib/action.js\n * Copyright(c) 2013 tangyao<tangyao@alibaba-inc.com>\n * MIT Licensed\n */\n\n'use strict';\n\nvar util = require('util');\nvar errors = require('./errors');\nvar KeyValue = require('./keyvalue');\nvar Bytes = require('./util/bytes');\nvar OperationWithAttributes = require('./operation_with_attributes');\nvar HConstants = require('./hconstants');\nvar HbaseObjectWritable = require('./io/hbase_object_writable');\n\n/*\n * A Get, Put or Delete associated with it's region.  Used internally by\n * {@link HTable::batch} to associate the action with it's region and maintain\n * the index from the original request.\n * @param {Row} action\n * @param {int} originalIndex\n */\nfunction Action(action, originalIndex) {\n  this.action = action;\n  this.originalIndex = originalIndex;\n  this.result = null;\n}\n\nAction.prototype.write = function (out) {\n  HbaseObjectWritable.writeObject(out, this.action);\n  out.writeInt(this.originalIndex);\n  // write null: null, 'Writable.class'\n  HbaseObjectWritable.writeObject(out, this.result, this.result ? this.result.constructor : 'Writable.class');\n};\n\n\nmodule.exports = Action;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/hregion_info.js":"/**!\n * node-hbase-client - lib/hregion_info.js\n *\n * Copyright(c) Alibaba Group Holding Limited.\n * MIT Licensed\n *\n * Authors:\n *   苏千 <suqian.yf@alibaba-inc.com> (http://fengmk2.github.com)\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Long = require('long');\nvar IOException = require('./errors').IOException;\nvar md5 = require('utility').md5;\nvar Bytes = require('./util/bytes');\nvar HConstants = require('./hconstants');\n\n/**\n * Make a region name of passed parameters.\n *\n * @param tableName\n * @param startKey Can be null\n * @param id Region id (Usually timestamp from when region was created).\n * @param newFormat should we create the region name in the new format\n *                  (such that it contains its encoded name?).\n * @return Region name made of passed tableName, startKey and id\n */\nvar createRegionName = function (tableName, startKey, id, newFormat) {\n  if (!Buffer.isBuffer(tableName)) {\n    tableName = Bytes.toBytes(tableName);\n  }\n  if (id instanceof Long || typeof id === 'number') {\n    id = id.toString();\n  }\n  if (typeof id === 'string') {\n    id = Bytes.toBytes(id);\n  }\n  var length = tableName.length + 2 + id.length + (!startKey ? 0 : startKey.length) +\n    (newFormat ? (HRegionInfo.MD5_HEX_LENGTH + 2) : 0);\n  var b = new Buffer(length);\n\n  var offset = 0;\n  tableName.copy(b, offset);\n  offset += tableName.length;\n  // System.arraycopy(tableName, 0, b, 0, offset);\n  b[offset++] = HRegionInfo.DELIMITER;\n  if (startKey && startKey.length > 0) {\n    // System.arraycopy(startKey, 0, b, offset, startKey.length);\n    startKey.copy(b, offset);\n    offset += startKey.length;\n  }\n  b[offset++] = HRegionInfo.DELIMITER;\n  id.copy(b, offset);\n  // System.arraycopy(id, 0, b, offset, id.length);\n  offset += id.length;\n\n  if (newFormat) {\n    //\n    // Encoded name should be built into the region name.\n    //\n    // Use the region name thus far (namely, <tablename>,<startKey>,<id>)\n    // to compute a MD5 hash to be used as the encoded name, and append\n    // it to the byte buffer.\n    //\n    // var md5Hash = MD5Hash.getMD5AsHex(b, 0, offset);\n    var md5Hash = md5(b.slice(0, offset));\n    var md5HashBytes = Bytes.toBytes(md5Hash);\n\n    if (md5HashBytes.length !== HRegionInfo.MD5_HEX_LENGTH) {\n      console.error(\"MD5-hash length mismatch: Expected=\" + HRegionInfo.MD5_HEX_LENGTH +\n        \"; Got=\" + md5HashBytes.length);\n    }\n\n    // now append the bytes '.<encodedName>.' to the end\n    b[offset++] = HRegionInfo.ENC_SEPARATOR;\n    md5HashBytes.copy(b, offset);\n    // System.arraycopy(md5HashBytes, 0, b, offset, MD5_HEX_LENGTH);\n    offset += HRegionInfo.MD5_HEX_LENGTH;\n    b[offset++] = HRegionInfo.ENC_SEPARATOR;\n  }\n\n  return b;\n};\n\n/**\n * HRegion information.\n * Contains HRegion id, start and end keys, a reference to this\n * HRegions' table descriptor, etc.\n */\nfunction HRegionInfo(regionId, tableName, startKey, endKey, split) {\n  /**\n   * Construct HRegionInfo with explicit parameters\n   *\n   * @param tableName the table descriptor\n   * @param startKey first key in region\n   * @param endKey end of key range\n   * @param split true if this region has split and we have daughter regions\n   * regions that may or may not hold references to this region.\n   * @param regionid Region id to use.\n   */\n  this.tableName = tableName;\n\n  // This flag is in the parent of a split while the parent is still referenced\n  // by daughter regions.  We USED to set this flag when we disabled a table\n  // but now table state is kept up in zookeeper as of 0.90.0 HBase.\n  this.offLine = false;\n  this.regionId = regionId;\n\n  if (!tableName) {\n    return;\n  }\n\n  var newFormat = true;\n  if (Bytes.equals(tableName, HConstants.ROOT_TABLE_NAME) || Bytes.equals(tableName, HConstants.META_TABLE_NAME)) {\n    newFormat = false;\n  }\n  this.regionName = createRegionName(this.tableName, startKey, this.regionId, newFormat);\n\n  this.regionNameStr = Bytes.toStringBinary(this.regionName);\n  this.split = split;\n  if (endKey === undefined || endKey === null) {\n    endKey = HConstants.EMPTY_END_ROW;\n  }\n  if (startKey === undefined || startKey === null) {\n    startKey = HConstants.EMPTY_START_ROW;\n  }\n  this.endKey = endKey;\n  this.startKey = startKey;\n}\n\n/**\n * The new format for a region name contains its encodedName at the end.\n * The encoded name also serves as the directory name for the region\n * in the filesystem.\n *\n * New region name format:\n *    &lt;tablename>,,&lt;startkey>,&lt;regionIdTimestamp>.&lt;encodedName>.\n * where,\n *    &lt;encodedName> is a hex version of the MD5 hash of\n *    &lt;tablename>,&lt;startkey>,&lt;regionIdTimestamp>\n *\n * The old region name format:\n *    &lt;tablename>,&lt;startkey>,&lt;regionIdTimestamp>\n * For region names in the old format, the encoded name is a 32-bit\n * JenkinsHash integer value (in its decimal notation, string form).\n *<p>\n * **NOTE**\n *\n * ROOT, the first META region, and regions created by an older\n * version of HBase (0.20 or prior) will continue to use the\n * old region name format.\n */\n\n// VERSION == 0 when HRegionInfo had an HTableDescriptor inside it.\nHRegionInfo.VERSION_PRE_092 = 0;\nHRegionInfo.VERSION = 1;\n/** Separator used to demarcate the encodedName in a region name\n * in the new format. See description on new format above.\n */\nHRegionInfo.ENC_SEPARATOR = '.'.charCodeAt(0);\nHRegionInfo.MD5_HEX_LENGTH = 32;\n\n/** delimiter used between portions of a region name */\nHRegionInfo.DELIMITER = ','.charCodeAt(0);\n\n/**\n * Does region name contain its encoded name?\n *\n * @param regionName region name\n * @return boolean indicating if this a new format region\n *         name which contains its encoded name.\n */\nHRegionInfo.hasEncodedName = function (regionName) {\n  // check if region name ends in ENC_SEPARATOR\n  if ((regionName.length >= 1) && (regionName[regionName.length - 1] === HRegionInfo.ENC_SEPARATOR)) {\n    // region name is new format. it contains the encoded name.\n    return true;\n  }\n  return false;\n};\n\n/**\n * @param regionName\n * @return the encodedName\n */\nHRegionInfo.encodeRegionName = function (regionName) {\n  var encodedName;\n  if (HRegionInfo.hasEncodedName(regionName)) {\n    // region is in new format:\n    // <tableName>,<startKey>,<regionIdTimeStamp>/encodedName/\n    // encodedName = Bytes.toString(regionName,\n    //   regionName.length - HRegionInfo.MD5_HEX_LENGTH - 1,\n    //   HRegionInfo.MD5_HEX_LENGTH);\n    var offset = regionName.length - HRegionInfo.MD5_HEX_LENGTH - 1;\n    encodedName = Bytes.toString(regionName.slice(offset, offset + HRegionInfo.MD5_HEX_LENGTH));\n  } else {\n    encodedName = Bytes.toString(regionName);\n    // old format region name. ROOT and first META region also\n    // use this format.EncodedName is the JenkinsHash value.\n    // var hashVal = Math.abs(JenkinsHash.getInstance().hash(regionName, regionName.length, 0));\n    // encodedName = String.valueOf(hashVal);\n  }\n  return encodedName;\n};\n\n /**\n * Use logging.\n *\n * @param encodedRegionName The encoded regionname.\n * @return <code>-ROOT-</code> if passed <code>70236052</code> or\n * <code>.META.</code> if passed </code>1028785192</code> else returns\n * <code>encodedRegionName</code>\n */\nHRegionInfo.prettyPrint = function (encodedRegionName) {\n  if (encodedRegionName.equals(\"70236052\")) {\n    return encodedRegionName + \"/-ROOT-\";\n  } else if (encodedRegionName.equals(\"1028785192\")) {\n    return encodedRegionName + \"/.META.\";\n  }\n  return encodedRegionName;\n};\n\n/**\n * Gets the table name from the specified region name.\n *\n * @param regionName\n * @return Table name.\n */\nHRegionInfo.getTableName = function (regionName) {\n  var offset = -1;\n  for (var i = 0; i < regionName.length; i++) {\n    if (regionName[i] === HRegionInfo.DELIMITER) {\n      offset = i;\n      break;\n    }\n  }\n  // var tableName = new byte[offset];\n  // System.arraycopy(regionName, 0, tableName, 0, offset);\n  return regionName.slice(0, offset);\n};\n\n/**\n * Separate elements of a regionName.\n *\n * @param regionName\n * @return Array of byte[] containing tableName, startKey and id\n */\nHRegionInfo.parseRegionName = function (regionName) {\n  var offset = -1;\n  for (var i = 0; i < regionName.length; i++) {\n    if (regionName[i] === HRegionInfo.DELIMITER) {\n      offset = i;\n      break;\n    }\n  }\n  if (offset === -1) {\n    throw new IOException(\"Invalid regionName format\");\n  }\n  // byte[] tableName = new byte[offset];\n  // System.arraycopy(regionName, 0, tableName, 0, offset);\n  var tableName = regionName.slice(0, offset);\n  offset = -1;\n  for (i = regionName.length - 1; i > 0; i--) {\n    if (regionName[i] === HRegionInfo.DELIMITER) {\n      offset = i;\n      break;\n    }\n  }\n  if (offset === -1) {\n    throw new IOException(\"Invalid regionName format\");\n  }\n  var startKey = HConstants.EMPTY_BYTE_ARRAY;\n  if (offset !== tableName.length + 1) {\n    // startKey = new byte[offset - tableName.length - 1];\n    // System.arraycopy(regionName, tableName.length + 1, startKey, 0, offset - tableName.length - 1);\n    startKey = regionName.slice(tableName.length + 1, offset);\n  }\n  var idOffset = offset + 1;\n  var idLength = regionName.length - offset - 1;\n  // var id = new byte[regionName.length - offset - 1];\n  // System.arraycopy(regionName, offset + 1, id, 0, regionName.length - offset - 1);\n  var id = regionName.slice(idOffset, idOffset + idLength);\n  // byte[][] elements = new byte[3][];\n  // elements[0] = tableName;\n  // elements[1] = startKey;\n  // elements[2] = id;\n  return [\n    tableName,\n    startKey,\n    id\n  ];\n};\n\n/**\n * @return the regionName as an array of bytes.\n */\nHRegionInfo.prototype.getRegionName = function () {\n  return this.regionName;\n};\n\n/** @return the startKey */\nHRegionInfo.prototype.getStartKey = function () {\n  return this.startKey;\n};\n\n/** @return the endKey */\nHRegionInfo.prototype.getEndKey = function () {\n  return this.endKey;\n};\n\n/**\n * Get current table name of the region\n *\n * @return byte array of table name\n */\nHRegionInfo.prototype.getTableName = function () {\n  if (!this.tableName || this.tableName.length === 0) {\n    this.tableName = HRegionInfo.getTableName(this.getRegionName());\n  }\n  return this.tableName;\n};\n\n/**\n * Get current table name as string\n *\n * @return string representation of current table\n */\nHRegionInfo.prototype.getTableNameAsString = function () {\n  return Bytes.toString(this.getTableName());\n};\n\n/**\n * Returns true if the given inclusive range of rows is fully contained\n * by this region. For example, if the region is foo,a,g and this is\n * passed [\"b\",\"c\"] or [\"a\",\"c\"] it will return true, but if this is passed\n * [\"b\",\"z\"] it will return false.\n */\nHRegionInfo.prototype.containsRange = function (rangeStartKey, rangeEndKey) {\n  var firstKeyInRange = Bytes.compareTo(rangeStartKey, this.startKey) >= 0;\n  var lastKeyInRange = Bytes.compareTo(rangeEndKey, this.endKey) < 0 ||\n    Bytes.equals(this.endKey, HConstants.EMPTY_BYTE_ARRAY);\n  return firstKeyInRange && lastKeyInRange;\n};\n\n/**\n * Return true if the given row falls in this region.\n */\nHRegionInfo.prototype.containsRow = function (row) {\n  return Bytes.compareTo(row, this.startKey) >= 0 &&\n    (Bytes.compareTo(row, this.endKey) < 0 || Bytes.equals(this.endKey, HConstants.EMPTY_BYTE_ARRAY));\n};\n\n/** @return true if this is the root region */\nHRegionInfo.prototype.isRootRegion = function () {\n  return Bytes.equals(this.tableName, HRegionInfo.ROOT_REGIONINFO.getTableName());\n};\n\n/** @return true if this region is from a table that is a meta table,\n * either <code>.META.</code> or <code>-ROOT-</code>\n */\nHRegionInfo.prototype.isMetaTable = function () {\n  return this.isRootRegion() || this.isMetaRegion();\n};\n\n/** @return true if this region is a meta region */\nHRegionInfo.prototype.isMetaRegion = function () {\n  return Bytes.equals(this.tableName, HRegionInfo.FIRST_META_REGIONINFO.getTableName());\n};\n\n/**\n * @return True if has been split and has daughters.\n */\nHRegionInfo.prototype.isSplit = function () {\n  return this.split;\n};\n\n/**\n * @param split set split status\n */\nHRegionInfo.prototype.setSplit = function (split) {\n  this.split = split;\n};\n\n/**\n * @return True if this region is offline.\n */\nHRegionInfo.prototype.isOffline = function () {\n  return this.offLine;\n};\n\n/**\n * The parent of a region split is offline while split daughters hold\n * references to the parent. Offlined regions are closed.\n *\n * @param offLine Set online/offline status.\n */\nHRegionInfo.prototype.setOffline = function (offLine) {\n  this.offLine = offLine;\n};\n\n/**\n * @return True if this is a split parent region.\n */\nHRegionInfo.prototype.isSplitParent = function () {\n  if (!this.isSplit()) {\n    return false;\n  }\n  if (!this.isOffline()) {\n    console.warn(\"Region is split but NOT offline: \" + this);\n  }\n  return true;\n};\n\n/**\n * @see java.lang.Object#toString()\n */\nHRegionInfo.prototype.toString = function () {\n  return \"{ID => \" + this.regionId.toString() + \", NAME => '\" + this.regionNameStr +\n    \"', STARTKEY => '\" + Bytes.toStringBinary(this.startKey) +\n    \"', ENDKEY => '\" + Bytes.toStringBinary(this.endKey) + \"', \" +\n    // \"', ENCODED => \" + this.getEncodedName() + \",\" +\n    (this.isOffline() ? \" OFFLINE => true,\" : \"\") + (this.isSplit() ? \" SPLIT => true,\" : \"\") + \"}\";\n};\n\n/** @return the object version number */\nHRegionInfo.prototype.getVersion = function () {\n  return HRegionInfo.VERSION;\n};\n\nHRegionInfo.prototype.readFields = function (io) {\n  // Read the single version byte.  We don't ask the super class do it\n  // because freaks out if its not the current classes' version.  This method\n  // can deserialize version 0 and version 1 of HRI.\n  var version = io.readByte();\n  if (version === 0) {\n    // This is the old HRI that carried an HTD.  Migrate it.  The below\n    // was copied from the old 0.90 HRI readFields.\n    this.endKey = Bytes.readByteArray(io);\n    this.offLine = io.readBoolean();\n    this.regionId = io.readLong();\n    this.regionName = Bytes.readByteArray(io);\n    this.regionNameStr = Bytes.toStringBinary(this.regionName);\n    this.split = io.readBoolean();\n    this.startKey = Bytes.readByteArray(io);\n    // try {\n    //   HTableDescriptor htd = new HTableDescriptor();\n    //   htd.readFields(in);\n    //   this.tableName = htd.getName();\n    // } catch (EOFException eofe) {\n    //   throw new IOException(\"HTD not found in input buffer\", eofe);\n    // }\n    this.hashCode = io.readInt();\n  } else if (this.getVersion() === version) {\n    this.endKey = io.readByteArray();\n    this.offLine = io.readBoolean();\n    this.regionId = io.readLong();\n    this.regionName = io.readByteArray();\n    this.regionNameStr = Bytes.toStringBinary(this.regionName);\n    this.split = io.readBoolean();\n    this.startKey = io.readByteArray();\n    this.tableName = io.readByteArray();\n    this.hashCode = io.readInt();\n  } else {\n    throw new IOException(\"Non-migratable/unknown version=\" + this.getVersion());\n  }\n};\n\nHRegionInfo.prototype.compareTo = function (o) {\n  if (!o) {\n    return 1;\n  }\n\n  // Are regions of same table?\n  var result = Bytes.compareTo(this.tableName, o.tableName);\n  if (result !== 0) {\n    return result;\n  }\n\n  // Compare start keys.\n  result = Bytes.compareTo(this.startKey, o.startKey);\n  if (result !== 0) {\n    return result;\n  }\n\n  // Compare end keys.\n  result = Bytes.compareTo(this.endKey, o.endKey);\n\n  if (result !== 0) {\n    if (this.startKey.length !== 0 && this.endKey.length === 0) {\n      return 1; // this is last region\n    }\n    if (o.startKey.length !== 0 && o.endKey.length === 0) {\n      return -1; // o is the last region\n    }\n    return result;\n  }\n\n  // regionId is usually milli timestamp -- this defines older stamps\n  // to be \"smaller\" than newer stamps in sort order.\n  if (this.regionId.greaterThan(o.regionId)) {\n    return 1;\n  } else if (this.regionId.lessThan(o.regionId)) {\n    return -1;\n  }\n\n  if (this.offLine === o.offLine) {\n    return 0;\n  }\n\n  if (this.offLine === true) {\n    return -1;\n  }\n\n  return 1;\n};\n\nHRegionInfo.createRegionName = createRegionName;\n\n/** HRegionInfo for root region */\nHRegionInfo.ROOT_REGIONINFO = new HRegionInfo(0, HConstants.ROOT_TABLE_NAME);\nHRegionInfo.ROOT_REGIONINFO.isRoot = true;\n\n/** HRegionInfo for first meta region */\nHRegionInfo.FIRST_META_REGIONINFO = new HRegionInfo(1, HConstants.META_TABLE_NAME);\nHRegionInfo.FIRST_META_REGIONINFO.isMeta = true;\n\n\nmodule.exports = HRegionInfo;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/hregion_location.js":"/*!\n * node-hbase-client - lib/hregion_location.js\n * Copyright(c) 2013 fengmk2 <fengmk2@gmail.com>\n * MIT Licensed\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\n/**\n * Data structure to hold HRegionInfo and the address for the hosting\n * HRegionServer.  Immutable.  Comparable, but we compare the 'location' only:\n * i.e. the hostname and port, and *not* the regioninfo.  This means two\n * instances are the same if they refer to the same 'location' (the same\n * hostname and port), though they may be carrying different regions.\n */\nfunction HRegionLocation(regionInfo, hostname, port) {\n  // Cache of the 'toString' result.\n  this.cachedString = null;\n  // Cache of the hostname + port\n  this.cachedHostnamePort = null;\n\n  /**\n   * Constructor\n   * @param regionInfo the HRegionInfo for the region\n   * @param hostname Hostname\n   * @param port port\n   */\n  // public HRegionLocation(HRegionInfo regionInfo, final String hostname, final int port) {\n  this.regionInfo = regionInfo;\n  this.hostname = hostname;\n  this.port = port;\n}\n\nHRegionLocation.prototype = {\n  toString: function () {\n    if (this.cachedString === null) {\n      this.cachedString = \"region=\" + this.regionInfo.toString() + \n        \", hostname=\" + this.hostname + \", port=\" + this.port;\n    }\n    return this.cachedString;\n  },\n\n  /** @return HRegionInfo */\n  getRegionInfo: function () {\n    return this.regionInfo;\n  },\n\n  getServerAddress: function () {\n    return {hostname: this.hostname, port: this.port};\n  },\n\n  getHostname: function () {\n    return this.hostname;\n  },\n\n  getPort: function () {\n    return this.port;\n  },\n\n  getHostnamePort: function () {\n    if (this.cachedHostnamePort === null) {\n      this.cachedHostnamePort = this.hostname + ':' + this.port;\n    }\n    return this.cachedHostnamePort;\n  },\n};\n\n\nmodule.exports = HRegionLocation;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/index.js":"/**!\n * node-hbase-client - lib/filters/index.js\n *\n * Copyright(c) 2014 Alibaba Group Holding Limited.\n *\n * Authors:\n *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nexports.FilterList = require('./filterlist');\nexports.FirstKeyOnlyFilter = require('./first_keyonly');\nexports.KeyOnlyFilter = require('./keyonly');\nexports.ColumnPrefixFilter = require('./columnprefix');\nexports.ColumnRangeFilter = require('./columnrange');\nexports.SingleColumnValueFilter = require('./single_column_value');\nexports.BinaryComparator = require('./binary_comparator');\nexports.BinaryPrefixComparator = require('./binary_prefix_comparator');\nexports.BitComparator = require('./bit_comparator');\nexports.NullComparator = require('./null_comparator');\nexports.RegexStringComparator = require('./regex_string_comparator');\nexports.SubstringComparator = require('./substring_comparator');\nexports.RowFilter = require('./row');","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/filterlist.js":"/**!\n * node-hbase-client - lib/filters/filterlist.js\n *\n * Copyright(c) 2014 Alibaba Group Holding Limited.\n *\n * Authors:\n *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\nvar util = require('util');\nvar HbaseObjectWritable = require('../io/hbase_object_writable');\n\n/**\n * Implementation of {@link Filter} that represents an ordered List of Filters\n * which will be evaluated with a specified boolean operator {@link Operator#MUST_PASS_ALL}\n * (<code>AND</code>) or {@link Operator#MUST_PASS_ONE} (<code>OR</code>).\n * Since you can use Filter Lists as children of Filter Lists, you can create a\n * hierarchy of filters to be evaluated.\n *\n * <br/>\n * {@link Operator#MUST_PASS_ALL} evaluates lazily: evaluation stops as soon as one filter does\n * not include the KeyValue.\n *\n * <br/>\n * {@link Operator#MUST_PASS_ONE} evaluates non-lazily: all filters are always evaluated.\n *\n * <br/>\n * Defaults to {@link Operator#MUST_PASS_ALL}.\n * <p>TODO: Fix creation of Configuration on serialization and deserialization.\n */\n\nfunction FilterList(options) {\n  options = options || {};\n  this.operator = options.operator || FilterList.Operator.MUST_PASS_ALL;\n  this.filters = [];\n}\n\nFilterList.MAX_LOG_FILTERS = 5;\n\nFilterList.Operator = {\n  MUST_PASS_ALL: 0,\n  MUST_PASS_ONE: 1\n};\n\nFilterList.classname = 'org.apache.hadoop.hbase.filter.FilterList';\n\nFilterList.prototype.getClass = function () {\n  return {getName: function() {return FilterList.classname;}};\n};\n\nvar proto = FilterList.prototype;\n\nproto.write = function (out) {\n  out.writeByte(this.operator);\n  out.writeInt(this.filters.length);\n  for (var i = 0; i < this.filters.length; i++) {\n    // org.apache.hadoop.hbase.io.Writable\n    HbaseObjectWritable.writeObject(out, this.filters[i], 'Writable.class');\n  }\n};\n\nproto.addFilter = function (filter) {\n  this.filters.push(filter);\n};\n\nproto.toString = function () {\n  var endIndex = this.filters.length;\n  if (endIndex > FilterList.MAX_LOG_FILTERS) {\n    endIndex = FilterList.MAX_LOG_FILTERS;\n  }\n  return util.format('%s %s (%d/%d): %s',\n    this.constructor.name,\n    this.operator === FilterList.Operator.MUST_PASS_ALL ? 'AND' : 'OR',\n    endIndex,\n    this.filters.length,\n    this.filters.slice(0, endIndex).toString()\n  );\n};\n\nmodule.exports = FilterList;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/first_keyonly.js":"/**!\n * node-hbase-client - lib/filters/first_keyonly.js\n *\n * Copyright(c) 2014 Alibaba Group Holding Limited.\n *\n * Authors:\n *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\n/**\n * A filter that will only return the first KV from each row.\n * <p>\n * This filter can be used to more efficiently perform row count operations.\n */\nfunction FirstKeyOnlyFilter() {\n\n}\n\nFirstKeyOnlyFilter.classname = 'org.apache.hadoop.hbase.filter.FirstKeyOnlyFilter';\n\nFirstKeyOnlyFilter.prototype.write = function (out) {};\n\nFirstKeyOnlyFilter.prototype.toString = function () {\n  return 'FirstKeyOnlyFilter';\n};\n\nmodule.exports = FirstKeyOnlyFilter;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/keyonly.js":"/**!\n * node-hbase-client - lib/filters/keyonly.js\n *\n * Copyright(c) 2014 Alibaba Group Holding Limited.\n *\n * Authors:\n *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\n/**\n * A filter that will only return the key component of each KV (the value will\n * be rewritten as empty).\n * <p>\n * This filter can be used to grab all of the keys without having to also grab\n * the values.\n */\nfunction KeyOnlyFilter(lenAsVal) {\n  this.lenAsVal = !!lenAsVal;\n}\n\nKeyOnlyFilter.classname = 'org.apache.hadoop.hbase.filter.KeyOnlyFilter';\n\nKeyOnlyFilter.prototype.write = function (out) {\n  out.writeBoolean(this.lenAsVal);\n};\n\nKeyOnlyFilter.prototype.toString = function () {\n  return 'KeyOnlyFilter(lenAsVal: ' + this.lenAsVal + ')';\n};\n\nmodule.exports = KeyOnlyFilter;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/columnprefix.js":"/**!\n * node-hbase-client - lib/filters/columnprefix.js\n *\n *\n *\n * Authors:\n *   Martin Cizek <martin.cizek@socialbakers.com> (http://github.com/wision)\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\n/**\n\n */\nfunction ColumnPrefixFilter(prefix) {\n  prefix = prefix === undefined ? '' : prefix;\n\n  if (!Buffer.isBuffer(prefix)) {\n    prefix = new Buffer(prefix);\n  }\n\n  this.prefix = prefix;\n}\n\nColumnPrefixFilter.classname = 'org.apache.hadoop.hbase.filter.ColumnPrefixFilter';\n\nColumnPrefixFilter.prototype.write = function (out) {\n  out.writeByte(this.prefix.length);\n  out.writeBytes(this.prefix);\n};\n\nColumnPrefixFilter.prototype.getClass = function () {\n  return {getName: function() {return ColumnPrefixFilter.classname;}};\n};\n\nColumnPrefixFilter.prototype.toString = function () {\n  return 'ColumnPrefixFilter(prefix: ' + this.prefix + ')';\n};\n\nmodule.exports = ColumnPrefixFilter;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/columnrange.js":"/**!\n * node-hbase-client - lib/filters/columnprange.js\n *\n *\n *\n * Authors:\n *   Martin Cizek <martin.cizek@socialbakers.com> (http://github.com/wision)\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\n\n/**\n\n */\nfunction ColumnRangeFilter(minColumn, minColumnInclusive, maxColumn, maxColumnInclusive) {\n  minColumn = minColumn === undefined ? '' : minColumn;\n  maxColumn = maxColumn === undefined ? '' : maxColumn;\n\n  if (!Buffer.isBuffer(minColumn)) {\n    minColumn = new Buffer(minColumn);\n  }\n  if (!Buffer.isBuffer(maxColumn)) {\n    maxColumn = new Buffer(maxColumn);\n  }\n\n  this.minColumn = minColumn;\n  this.maxColumn = maxColumn;\n  this.minColumnInclusive = minColumnInclusive === null ? true : minColumnInclusive;\n  this.maxColumnInclusive = maxColumnInclusive === null ? false : maxColumnInclusive;\n}\n\nColumnRangeFilter.classname = 'org.apache.hadoop.hbase.filter.ColumnRangeFilter';\n\nColumnRangeFilter.prototype.write = function (out) {\n  out.writeBoolean(this.minColumn === null);\n  if (this.minColumn) {\n    out.writeByte(this.minColumn.length);\n    out.writeBytes(this.minColumn);\n  } else {\n    out.writeByte(0);\n  }\n  out.writeBoolean(this.minColumnInclusive);\n\n  out.writeBoolean(this.maxColumn === null);\n  if (this.maxColumn) {\n    out.writeByte(this.maxColumn.length);\n    out.writeBytes(this.maxColumn);\n  } else {\n    out.writeByte(0);\n  }\n  out.writeBoolean(this.maxColumnInclusive);\n};\n\nColumnRangeFilter.prototype.getClass = function () {\n  return {getName: function() {return ColumnRangeFilter.classname;}};\n};\n\nColumnRangeFilter.prototype.toString = function () {\n  return 'ColumnRangeFilter(minColumn: ' + this.minColumn+ ', minColumnInclusive: ' + this.minColumnInclusive + ', minColumn: ' + this.maxColumn + ', minColumnInclusive: ' + this.maxColumnInclusive + ')';\n};\n\nmodule.exports = ColumnRangeFilter;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/single_column_value.js":"/**!\n * node-hbase-client - lib/filters/single_column_value.js\n *\n *\n *\n * Authors:\n *   Takayuki Hasegawa <takayuki.hasegawa@gree.net>\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar Bytes = require('../util/bytes');\nvar WritableUtils = require('../writable_utils');\nvar HbaseObjectWritable = require('../io/hbase_object_writable');\nvar BinaryComparator = require('./binary_comparator');\n\n/**\n * This filter is used to filter cells based on value. It takes a {@link CompareFilter.CompareOp}\n * operator (equal, greater, not equal, etc), and either a byte [] value or\n * a WritableByteArrayComparable.\n * <p>\n * If we have a byte [] value then we just do a lexicographic compare. For\n * example, if passed value is 'b' and cell has 'a' and the compare operator\n * is LESS, then we will filter out this cell (return true).  If this is not\n * sufficient (eg you want to deserialize a long and then compare it to a fixed\n * long value), then you can pass in your own comparator instead.\n * <p>\n * You must also specify a family and qualifier.  Only the value of this column\n * will be tested. When using this filter on a {@link Scan} with specified\n * inputs, the column to be tested should also be added as input (otherwise\n * the filter will regard the column as missing).\n * <p>\n * To prevent the entire row from being emitted if the column is not found\n * on a row, use {@link #setFilterIfMissing}.\n * Otherwise, if the column is found, the entire row will be emitted only if\n * the value passes.  If the value fails, the row will be filtered out.\n * <p>\n * In order to test values of previous versions (timestamps), set\n * {@link #setLatestVersionOnly} to false. The default is true, meaning that\n * only the latest version's value is tested and all previous versions are ignored.\n * <p>\n * To filter based on the value of all scanned columns, use {@link ValueFilter}.\n */\nfunction SingleColumnValueFilter(family, qualifier, compareOp, value) {\n  if (!Buffer.isBuffer(family)) {\n    family = new Buffer(family);\n  }\n  if (!Buffer.isBuffer(qualifier)) {\n    qualifier = new Buffer(qualifier);\n  }\n  if (typeof value === \"string\") {\n    value = new Buffer(value);\n  }\n  if (Buffer.isBuffer(value)) {\n    value = new BinaryComparator(value);\n  }\n  this.family = family;\n  this.qualifier = qualifier;\n  this.compareOp = compareOp;\n  this.comparator = value;\n\n  this.foundColumn = false;\n  this.matchedColumn = false;\n  this.filterIfMissing = false;\n  this.latestVersionOnly = true;\n}\n\nSingleColumnValueFilter.classname = 'org.apache.hadoop.hbase.filter.SingleColumnValueFilter';\n\nSingleColumnValueFilter.prototype.write = function (out) {\n  Bytes.writeByteArray(out, this.family);\n  Bytes.writeByteArray(out, this.qualifier);\n  out.writeUTF(this.compareOp);\n  HbaseObjectWritable.writeObject(out, this.comparator, 'Writable.class');\n  out.writeBoolean(this.foundColumn);\n  out.writeBoolean(this.matchedColumn);\n  out.writeBoolean(this.filterIfMissing);\n  out.writeBoolean(this.latestVersionOnly);\n};\n\nSingleColumnValueFilter.prototype.getClass = function () {\n  return {getName: function() {return SingleColumnValueFilter.classname;}};\n};\n\nSingleColumnValueFilter.prototype.toString = function () {\n  return 'SingleColumnValueFilter(family: ' + this.family + ', qualifier: ' + this.qualifier + ', compareOp: ' + this.compareOp + ', comparator: ' + this.comparator + ')';\n};\n\nSingleColumnValueFilter.prototype.setFilterIfMissing = function (filterIfMissing) {\n  this.filterIfMissing = filterIfMissing;\n};\n\nSingleColumnValueFilter.prototype.setLatestVersionOnly = function (latestVersionOnly) {\n  this.latestVersionOnly = latestVersionOnly;\n};\n\nmodule.exports = SingleColumnValueFilter;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/binary_comparator.js":"/**!\n * node-hbase-client - lib/filters/binary_comparator.js\n *\n *\n *\n * Authors:\n *   Takayuki Hasegawa <takayuki.hasegawa@gree.net>\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar Bytes = require('../util/bytes');\n\n/**\n * A binary comparator which lexicographically compares against the specified\n * byte array using {@link org.apache.hadoop.hbase.util.Bytes#compareTo(byte[], byte[])}.\n */\nfunction BinaryComparator(value) {\n  if (!Buffer.isBuffer(value)) {\n    value = new Buffer(value);\n  }\n  this.value = value;\n}\n\nBinaryComparator.classname = 'org.apache.hadoop.hbase.filter.BinaryComparator';\n\nBinaryComparator.prototype.toString = function () {\n  return 'BinaryComparator(value: ' + this.value + ')';\n};\n\nBinaryComparator.prototype.write = function (out) {\n  Bytes.writeByteArray(out, this.value);\n};\n\nmodule.exports = BinaryComparator;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/binary_prefix_comparator.js":"/**!\n * node-hbase-client - lib/filters/binary_prefix_comparator.js\n *\n *\n *\n * Authors:\n *   Takayuki Hasegawa <takayuki.hasegawa@gree.net>\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar Bytes = require('../util/bytes');\n\n/**\n * A comparator which compares against a specified byte array, but only compares\n * up to the length of this byte array. For the rest it is similar to\n * {@link BinaryComparator}.\n */\nfunction BinaryPrefixComparator(value) {\n  if (!Buffer.isBuffer(value)) {\n    value = new Buffer(value);\n  }\n  this.value = value;\n}\n\nBinaryPrefixComparator.classname = 'org.apache.hadoop.hbase.filter.BinaryPrefixComparator';\n\nBinaryPrefixComparator.prototype.toString = function () {\n  return 'BinaryPrefixComparator(value: ' + this.value + ')';\n};\n\nBinaryPrefixComparator.prototype.write = function (out) {\n  Bytes.writeByteArray(out, this.value);\n};\n\nmodule.exports = BinaryPrefixComparator;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/bit_comparator.js":"/**!\n * node-hbase-client - lib/filters/bit_comparator.js\n *\n *\n *\n * Authors:\n *   Takayuki Hasegawa <takayuki.hasegawa@gree.net>\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar Bytes = require('../util/bytes');\n\n/**\n * A bit comparator which performs the specified bitwise operation on each of the bytes\n * with the specified byte array. Then returns whether the result is non-zero.\n */\nfunction BitComparator(value, bitOperator) {\n  if (!Buffer.isBuffer(value)) {\n    value = new Buffer(value);\n  }\n  this.value = value;\n  this.bitOperator = bitOperator;\n}\n\nBitComparator.BitwiseOp = {\n  AND: 'AND',\n  OR: 'OR',\n  XOR: 'XOR'\n};\n\nBitComparator.classname = 'org.apache.hadoop.hbase.filter.BitComparator';\n\nBitComparator.prototype.toString = function () {\n  return 'BitComparator(value: ' + this.value + ', bitOperator: ' + this.bitOperator + ')';\n};\n\nBitComparator.prototype.write = function (out) {\n  Bytes.writeByteArray(out, this.value);\n  out.writeUTF(this.bitOperator);\n};\n\nmodule.exports = BitComparator;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/null_comparator.js":"/**!\n * node-hbase-client - lib/filters/null_comparator.js\n *\n *\n *\n * Authors:\n *   Takayuki Hasegawa <takayuki.hasegawa@gree.net>\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar Bytes = require('../util/bytes');\n\n/**\n * A binary comparator which lexicographically compares against the specified\n * byte array using {@link org.apache.hadoop.hbase.util.Bytes#compareTo(byte[], byte[])}.\n */\nfunction NullComparator() {\n  this.value = new Buffer(0);\n}\n\nNullComparator.classname = 'org.apache.hadoop.hbase.filter.NullComparator';\n\nNullComparator.prototype.toString = function () {\n  return 'NullComparator';\n};\n\nNullComparator.prototype.write = function (out) {\n  Bytes.writeByteArray(out, 0);\n};\n\nmodule.exports = NullComparator;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/regex_string_comparator.js":"/**!\n * node-hbase-client - lib/filters/regex_string_comparator.js\n *\n *\n *\n * Authors:\n *   Takayuki Hasegawa <takayuki.hasegawa@gree.net>\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar Bytes = require('../util/bytes');\n\n/**\n * This comparator is for use with {@link CompareFilter} implementations, such\n * as {@link RowFilter}, {@link QualifierFilter}, and {@link ValueFilter}, for\n * filtering based on the value of a given column. Use it to test if a given\n * regular expression matches a cell value in the column.\n * <p>\n * Only EQUAL or NOT_EQUAL comparisons are valid with this comparator.\n * <p>\n * For example:\n * <p>\n * <pre>\n * ValueFilter vf = new ValueFilter(CompareOp.EQUAL,\n *     new RegexStringComparator(\n *       // v4 IP address\n *       \"(((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3,3}\" +\n *         \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))(\\\\/[0-9]+)?\" +\n *         \"|\" +\n *       // v6 IP address\n *       \"((([\\\\dA-Fa-f]{1,4}:){7}[\\\\dA-Fa-f]{1,4})(:([\\\\d]{1,3}.)\" +\n *         \"{3}[\\\\d]{1,3})?)(\\\\/[0-9]+)?\"));\n * </pre>\n */\nfunction RegexStringComparator(expr) {\n  if (!Buffer.isBuffer(expr)) {\n    expr = new Buffer(expr);\n  }\n  this.pattern = expr;\n  this.charset = \"UTF-8\";\n}\n\nRegexStringComparator.classname = 'org.apache.hadoop.hbase.filter.RegexStringComparator';\n\nRegexStringComparator.prototype.toString = function () {\n  return 'RegexStringComparator(pattern: ' + this.pattern + ', charset: ' + this.charset + ')';\n};\n\nRegexStringComparator.prototype.setCharset = function (charset) {\n  this.charset = charset;\n};\n\nRegexStringComparator.prototype.write = function (out) {\n  out.writeUTF(this.pattern);\n  out.writeUTF(this.charset);\n};\n\nmodule.exports = RegexStringComparator;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/substring_comparator.js":"/**!\n * node-hbase-client - lib/filters/substring_comparator.js\n *\n *\n *\n * Authors:\n *   Takayuki Hasegawa <takayuki.hasegawa@gree.net>\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar Bytes = require('../util/bytes');\n\n/**\n * This comparator is for use with SingleColumnValueFilter, for filtering based on\n * the value of a given column. Use it to test if a given substring appears\n * in a cell value in the column. The comparison is case insensitive.\n * <p>\n * Only EQUAL or NOT_EQUAL tests are valid with this comparator.\n */\nfunction SubstringComparator(substr) {\n  if (!Buffer.isBuffer(substr)) {\n    substr = new Buffer(substr.toLowerCase());\n  }\n  this.substr = substr;\n}\n\nSubstringComparator.classname = 'org.apache.hadoop.hbase.filter.SubstringComparator';\n\nSubstringComparator.prototype.toString = function () {\n  return 'SubstringComparator(substr: ' + this.substr + ')';\n};\n\nSubstringComparator.prototype.write = function (out) {\n  out.writeUTF(this.substr);\n};\n\nmodule.exports = SubstringComparator;\n","/home/travis/build/npmtest/node-npmtest-hbase-client/node_modules/hbase-client/lib/filters/row.js":"/**!\n * node-hbase-client - lib/filters/row.js\n *\n *\n *\n * Authors:\n *   David Boyer <dave.github@yougeezer.co.uk>\n */\n\n\"use strict\";\n\n/**\n * Module dependencies.\n */\nvar HbaseObjectWritable = require('../io/hbase_object_writable');\nvar BinaryComparator = require('./binary_comparator');\n\n/**\n * This filter is used to filter rows based on another filter. It takes a {@link CompareFilter.CompareOp}\n * operator (equal, greater, not equal, etc), and either a byte [] value or\n * a WritableByteArrayComparable.\n * <p>\n * If we have a byte [] value then we just do a lexicographic compare. For\n * example, if passed value is 'b' and cell has 'a' and the compare operator\n * is LESS, then we will filter out this cell (return true).  If this is not\n * sufficient (eg you want to deserialize a long and then compare it to a fixed\n * long value), then you can pass in your own comparator instead.\n */\nfunction RowFilter(compareOp, value) {\n  if (typeof value === \"string\") {\n    value = new Buffer(value);\n  }\n  if (Buffer.isBuffer(value)) {\n    value = new BinaryComparator(value);\n  }\n  this.compareOp = compareOp;\n  this.comparator = value;\n}\n\nRowFilter.classname = 'org.apache.hadoop.hbase.filter.RowFilter';\n\nRowFilter.prototype.write = function (out) {\n  out.writeUTF(this.compareOp);\n  HbaseObjectWritable.writeObject(out, this.comparator, 'Writable.class');\n};\n\nRowFilter.prototype.getClass = function () {\n  return {getName: function() {return RowFilter.classname;}};\n};\n\nRowFilter.prototype.toString = function () {\n  return 'RowFilter(compareOp: ' + this.compareOp + ', comparator: ' + this.comparator + ')';\n};\n\nmodule.exports = RowFilter;\n"}